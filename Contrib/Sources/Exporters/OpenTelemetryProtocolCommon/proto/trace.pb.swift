// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: opentelemetry/proto/trace/v1/trace.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// SpanFlags represents constants used to interpret the
/// Span.flags field, which is protobuf 'fixed32' type and is to
/// be used as bit-fields. Each non-zero value defined in this enum is
/// a bit-mask.  To extract the bit-field, for example, use an
/// expression like:
///
///   (span.flags & SPAN_FLAGS_TRACE_FLAGS_MASK)
///
/// See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
///
/// Note that Span flags were introduced in version 1.1 of the
/// OpenTelemetry protocol.  Older Span producers do not set this
/// field, consequently consumers should not rely on the absence of a
/// particular flag bit to indicate the presence of a particular feature.
public enum Opentelemetry_Proto_Trace_V1_SpanFlags: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// The zero value for the enum. Should not be used for comparisons.
  /// Instead use bitwise "and" with the appropriate mask as shown above.
  case doNotUse // = 0

  /// Bits 0-7 are used for trace flags.
  case traceFlagsMask // = 255

  /// Bits 8 and 9 are used to indicate that the parent span or link span is remote.
  /// Bit 8 (`HAS_IS_REMOTE`) indicates whether the value is known.
  /// Bit 9 (`IS_REMOTE`) indicates whether the span or link is remote.
  case contextHasIsRemoteMask // = 256
  case contextIsRemoteMask // = 512
  case UNRECOGNIZED(Int)

  public init() {
    self = .doNotUse
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .doNotUse
    case 255: self = .traceFlagsMask
    case 256: self = .contextHasIsRemoteMask
    case 512: self = .contextIsRemoteMask
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .doNotUse: return 0
    case .traceFlagsMask: return 255
    case .contextHasIsRemoteMask: return 256
    case .contextIsRemoteMask: return 512
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Opentelemetry_Proto_Trace_V1_SpanFlags] = [
    .doNotUse,
    .traceFlagsMask,
    .contextHasIsRemoteMask,
    .contextIsRemoteMask,
  ]

}

/// TracesData represents the traces data that can be stored in a persistent storage,
/// OR can be embedded by other protocols that transfer OTLP traces data but do
/// not implement the OTLP protocol.
///
/// The main difference between this message and collector protocol is that
/// in this message there will not be any "control" or "metadata" specific to
/// OTLP protocol.
///
/// When new fields are added into this message, the OTLP request MUST be updated
/// as well.
public struct Opentelemetry_Proto_Trace_V1_TracesData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An array of ResourceSpans.
  /// For data coming from a single resource this array will typically contain
  /// one element. Intermediary nodes that receive data from multiple origins
  /// typically batch the data before forwarding further and in that case this
  /// array will contain multiple elements.
  public var resourceSpans: [Opentelemetry_Proto_Trace_V1_ResourceSpans] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A collection of ScopeSpans from a Resource.
public struct Opentelemetry_Proto_Trace_V1_ResourceSpans: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource for the spans in this message.
  /// If this field is not set then no resource info is known.
  public var resource: Opentelemetry_Proto_Resource_V1_Resource {
    get {return _resource ?? Opentelemetry_Proto_Resource_V1_Resource()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  /// A list of ScopeSpans that originate from a resource.
  public var scopeSpans: [Opentelemetry_Proto_Trace_V1_ScopeSpans] = []

  /// The Schema URL, if known. This is the identifier of the Schema that the resource data
  /// is recorded in. Notably, the last part of the URL path is the version number of the
  /// schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
  /// https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
  /// This schema_url applies to the data in the "resource" field. It does not apply
  /// to the data in the "scope_spans" field which have their own schema_url field.
  public var schemaURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _resource: Opentelemetry_Proto_Resource_V1_Resource? = nil
}

/// A collection of Spans produced by an InstrumentationScope.
public struct Opentelemetry_Proto_Trace_V1_ScopeSpans: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instrumentation scope information for the spans in this message.
  /// Semantically when InstrumentationScope isn't set, it is equivalent with
  /// an empty instrumentation scope name (unknown).
  public var scope: Opentelemetry_Proto_Common_V1_InstrumentationScope {
    get {return _scope ?? Opentelemetry_Proto_Common_V1_InstrumentationScope()}
    set {_scope = newValue}
  }
  /// Returns true if `scope` has been explicitly set.
  public var hasScope: Bool {return self._scope != nil}
  /// Clears the value of `scope`. Subsequent reads from it will return its default value.
  public mutating func clearScope() {self._scope = nil}

  /// A list of Spans that originate from an instrumentation scope.
  public var spans: [Opentelemetry_Proto_Trace_V1_Span] = []

  /// The Schema URL, if known. This is the identifier of the Schema that the span data
  /// is recorded in. Notably, the last part of the URL path is the version number of the
  /// schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
  /// https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
  /// This schema_url applies to all spans and span events in the "spans" field.
  public var schemaURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _scope: Opentelemetry_Proto_Common_V1_InstrumentationScope? = nil
}

/// A Span represents a single operation performed by a single component of the system.
///
/// The next available field id is 17.
public struct Opentelemetry_Proto_Trace_V1_Span: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier for a trace. All spans from the same trace share
  /// the same `trace_id`. The ID is a 16-byte array. An ID with all zeroes OR
  /// of length other than 16 bytes is considered invalid (empty string in OTLP/JSON
  /// is zero-length and thus is also invalid).
  ///
  /// This field is required.
  public var traceID: Data {
    get {return _storage._traceID}
    set {_uniqueStorage()._traceID = newValue}
  }

  /// A unique identifier for a span within a trace, assigned when the span
  /// is created. The ID is an 8-byte array. An ID with all zeroes OR of length
  /// other than 8 bytes is considered invalid (empty string in OTLP/JSON
  /// is zero-length and thus is also invalid).
  ///
  /// This field is required.
  public var spanID: Data {
    get {return _storage._spanID}
    set {_uniqueStorage()._spanID = newValue}
  }

  /// trace_state conveys information about request position in multiple distributed tracing graphs.
  /// It is a trace_state in w3c-trace-context format: https://www.w3.org/TR/trace-context/#tracestate-header
  /// See also https://github.com/w3c/distributed-tracing for more details about this field.
  public var traceState: String {
    get {return _storage._traceState}
    set {_uniqueStorage()._traceState = newValue}
  }

  /// The `span_id` of this span's parent span. If this is a root span, then this
  /// field must be empty. The ID is an 8-byte array.
  public var parentSpanID: Data {
    get {return _storage._parentSpanID}
    set {_uniqueStorage()._parentSpanID = newValue}
  }

  /// Flags, a bit field.
  ///
  /// Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
  /// Context specification. To read the 8-bit W3C trace flag, use
  /// `flags & SPAN_FLAGS_TRACE_FLAGS_MASK`.
  ///
  /// See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
  ///
  /// Bits 8 and 9 represent the 3 states of whether a span's parent
  /// is remote. The states are (unknown, is not remote, is remote).
  /// To read whether the value is known, use `(flags & SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
  /// To read whether the span is remote, use `(flags & SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
  ///
  /// When creating span messages, if the message is logically forwarded from another source
  /// with an equivalent flags fields (i.e., usually another OTLP span message), the field SHOULD
  /// be copied as-is. If creating from a source that does not have an equivalent flags field
  /// (such as a runtime representation of an OpenTelemetry span), the high 22 bits MUST
  /// be set to zero.
  /// Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
  ///
  /// [Optional].
  public var flags: UInt32 {
    get {return _storage._flags}
    set {_uniqueStorage()._flags = newValue}
  }

  /// A description of the span's operation.
  ///
  /// For example, the name can be a qualified method name or a file name
  /// and a line number where the operation is called. A best practice is to use
  /// the same display name at the same call point in an application.
  /// This makes it easier to correlate spans in different traces.
  ///
  /// This field is semantically required to be set to non-empty string.
  /// Empty value is equivalent to an unknown span name.
  ///
  /// This field is required.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Distinguishes between spans generated in a particular context. For example,
  /// two spans with the same name may be distinguished using `CLIENT` (caller)
  /// and `SERVER` (callee) to identify queueing latency associated with the span.
  public var kind: Opentelemetry_Proto_Trace_V1_Span.SpanKind {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  /// start_time_unix_nano is the start time of the span. On the client side, this is the time
  /// kept by the local machine where the span execution starts. On the server side, this
  /// is the time when the server's application handler starts running.
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
  ///
  /// This field is semantically required and it is expected that end_time >= start_time.
  public var startTimeUnixNano: UInt64 {
    get {return _storage._startTimeUnixNano}
    set {_uniqueStorage()._startTimeUnixNano = newValue}
  }

  /// end_time_unix_nano is the end time of the span. On the client side, this is the time
  /// kept by the local machine where the span execution ends. On the server side, this
  /// is the time when the server application handler stops running.
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
  ///
  /// This field is semantically required and it is expected that end_time >= start_time.
  public var endTimeUnixNano: UInt64 {
    get {return _storage._endTimeUnixNano}
    set {_uniqueStorage()._endTimeUnixNano = newValue}
  }

  /// attributes is a collection of key/value pairs. Note, global attributes
  /// like server name can be set using the resource API. Examples of attributes:
  ///
  ///     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
  ///     "/http/server_latency": 300
  ///     "example.com/myattribute": true
  ///     "example.com/score": 10.239
  ///
  /// The OpenTelemetry API specification further restricts the allowed value types:
  /// https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/README.md#attribute
  /// Attribute keys MUST be unique (it is not allowed to have more than one
  /// attribute with the same key).
  public var attributes: [Opentelemetry_Proto_Common_V1_KeyValue] {
    get {return _storage._attributes}
    set {_uniqueStorage()._attributes = newValue}
  }

  /// dropped_attributes_count is the number of attributes that were discarded. Attributes
  /// can be discarded because their keys are too long or because there are too many
  /// attributes. If this value is 0, then no attributes were dropped.
  public var droppedAttributesCount: UInt32 {
    get {return _storage._droppedAttributesCount}
    set {_uniqueStorage()._droppedAttributesCount = newValue}
  }

  /// events is a collection of Event items.
  public var events: [Opentelemetry_Proto_Trace_V1_Span.Event] {
    get {return _storage._events}
    set {_uniqueStorage()._events = newValue}
  }

  /// dropped_events_count is the number of dropped events. If the value is 0, then no
  /// events were dropped.
  public var droppedEventsCount: UInt32 {
    get {return _storage._droppedEventsCount}
    set {_uniqueStorage()._droppedEventsCount = newValue}
  }

  /// links is a collection of Links, which are references from this span to a span
  /// in the same or different trace.
  public var links: [Opentelemetry_Proto_Trace_V1_Span.Link] {
    get {return _storage._links}
    set {_uniqueStorage()._links = newValue}
  }

  /// dropped_links_count is the number of dropped links after the maximum size was
  /// enforced. If this value is 0, then no links were dropped.
  public var droppedLinksCount: UInt32 {
    get {return _storage._droppedLinksCount}
    set {_uniqueStorage()._droppedLinksCount = newValue}
  }

  /// An optional final status for this span. Semantically when Status isn't set, it means
  /// span's status code is unset, i.e. assume STATUS_CODE_UNSET (code = 0).
  public var status: Opentelemetry_Proto_Trace_V1_Status {
    get {return _storage._status ?? Opentelemetry_Proto_Trace_V1_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// SpanKind is the type of span. Can be used to specify additional relationships between spans
  /// in addition to a parent/child relationship.
  public enum SpanKind: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Unspecified. Do NOT use as default.
    /// Implementations MAY assume SpanKind to be INTERNAL when receiving UNSPECIFIED.
    case unspecified // = 0

    /// Indicates that the span represents an internal operation within an application,
    /// as opposed to an operation happening at the boundaries. Default value.
    case `internal` // = 1

    /// Indicates that the span covers server-side handling of an RPC or other
    /// remote network request.
    case server // = 2

    /// Indicates that the span describes a request to some remote service.
    case client // = 3

    /// Indicates that the span describes a producer sending a message to a broker.
    /// Unlike CLIENT and SERVER, there is often no direct critical path latency relationship
    /// between producer and consumer spans. A PRODUCER span ends when the message was accepted
    /// by the broker while the logical processing of the message might span a much longer time.
    case producer // = 4

    /// Indicates that the span describes consumer receiving a message from a broker.
    /// Like the PRODUCER kind, there is often no direct critical path latency relationship
    /// between producer and consumer spans.
    case consumer // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .internal
      case 2: self = .server
      case 3: self = .client
      case 4: self = .producer
      case 5: self = .consumer
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .internal: return 1
      case .server: return 2
      case .client: return 3
      case .producer: return 4
      case .consumer: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Opentelemetry_Proto_Trace_V1_Span.SpanKind] = [
      .unspecified,
      .internal,
      .server,
      .client,
      .producer,
      .consumer,
    ]

  }

  /// Event is a time-stamped annotation of the span, consisting of user-supplied
  /// text description and key-value pairs.
  public struct Event: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// time_unix_nano is the time the event occurred.
    public var timeUnixNano: UInt64 = 0

    /// name of the event.
    /// This field is semantically required to be set to non-empty string.
    public var name: String = String()

    /// attributes is a collection of attribute key/value pairs on the event.
    /// Attribute keys MUST be unique (it is not allowed to have more than one
    /// attribute with the same key).
    public var attributes: [Opentelemetry_Proto_Common_V1_KeyValue] = []

    /// dropped_attributes_count is the number of dropped attributes. If the value is 0,
    /// then no attributes were dropped.
    public var droppedAttributesCount: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A pointer from the current span to another span in the same trace or in a
  /// different trace. For example, this can be used in batching operations,
  /// where a single batch handler processes multiple requests from different
  /// traces or when the handler receives a request from a different project.
  public struct Link: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A unique identifier of a trace that this linked span is part of. The ID is a
    /// 16-byte array.
    public var traceID: Data = Data()

    /// A unique identifier for the linked span. The ID is an 8-byte array.
    public var spanID: Data = Data()

    /// The trace_state associated with the link.
    public var traceState: String = String()

    /// attributes is a collection of attribute key/value pairs on the link.
    /// Attribute keys MUST be unique (it is not allowed to have more than one
    /// attribute with the same key).
    public var attributes: [Opentelemetry_Proto_Common_V1_KeyValue] = []

    /// dropped_attributes_count is the number of dropped attributes. If the value is 0,
    /// then no attributes were dropped.
    public var droppedAttributesCount: UInt32 = 0

    /// Flags, a bit field.
    ///
    /// Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
    /// Context specification. To read the 8-bit W3C trace flag, use
    /// `flags & SPAN_FLAGS_TRACE_FLAGS_MASK`.
    ///
    /// See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
    ///
    /// Bits 8 and 9 represent the 3 states of whether the link is remote.
    /// The states are (unknown, is not remote, is remote).
    /// To read whether the value is known, use `(flags & SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
    /// To read whether the link is remote, use `(flags & SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
    ///
    /// Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
    /// When creating new spans, bits 10-31 (most-significant 22-bits) MUST be zero.
    ///
    /// [Optional].
    public var flags: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The Status type defines a logical error model that is suitable for different
/// programming environments, including REST APIs and RPC APIs.
public struct Opentelemetry_Proto_Trace_V1_Status: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A developer-facing human readable error message.
  public var message: String = String()

  /// The status code.
  public var code: Opentelemetry_Proto_Trace_V1_Status.StatusCode = .unset

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// For the semantics of status codes see
  /// https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/api.md#set-status
  public enum StatusCode: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// The default status.
    case unset // = 0

    /// The Span has been validated by an Application developer or Operator to 
    /// have completed successfully.
    case ok // = 1

    /// The Span contains an error.
    case error // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unset
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unset
      case 1: self = .ok
      case 2: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unset: return 0
      case .ok: return 1
      case .error: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Opentelemetry_Proto_Trace_V1_Status.StatusCode] = [
      .unset,
      .ok,
      .error,
    ]

  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "opentelemetry.proto.trace.v1"

extension Opentelemetry_Proto_Trace_V1_SpanFlags: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SPAN_FLAGS_DO_NOT_USE"),
    255: .same(proto: "SPAN_FLAGS_TRACE_FLAGS_MASK"),
    256: .same(proto: "SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK"),
    512: .same(proto: "SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK"),
  ]
}

extension Opentelemetry_Proto_Trace_V1_TracesData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TracesData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resource_spans"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.resourceSpans) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceSpans.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resourceSpans, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Trace_V1_TracesData, rhs: Opentelemetry_Proto_Trace_V1_TracesData) -> Bool {
    if lhs.resourceSpans != rhs.resourceSpans {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Trace_V1_ResourceSpans: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceSpans"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resource"),
    2: .standard(proto: "scope_spans"),
    3: .standard(proto: "schema_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.scopeSpans) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.schemaURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.scopeSpans.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.scopeSpans, fieldNumber: 2)
    }
    if !self.schemaURL.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Trace_V1_ResourceSpans, rhs: Opentelemetry_Proto_Trace_V1_ResourceSpans) -> Bool {
    if lhs._resource != rhs._resource {return false}
    if lhs.scopeSpans != rhs.scopeSpans {return false}
    if lhs.schemaURL != rhs.schemaURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Trace_V1_ScopeSpans: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScopeSpans"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
    2: .same(proto: "spans"),
    3: .standard(proto: "schema_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._scope) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.spans) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.schemaURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._scope {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.spans.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.spans, fieldNumber: 2)
    }
    if !self.schemaURL.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Trace_V1_ScopeSpans, rhs: Opentelemetry_Proto_Trace_V1_ScopeSpans) -> Bool {
    if lhs._scope != rhs._scope {return false}
    if lhs.spans != rhs.spans {return false}
    if lhs.schemaURL != rhs.schemaURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Trace_V1_Span: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Span"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trace_id"),
    2: .standard(proto: "span_id"),
    3: .standard(proto: "trace_state"),
    4: .standard(proto: "parent_span_id"),
    16: .same(proto: "flags"),
    5: .same(proto: "name"),
    6: .same(proto: "kind"),
    7: .standard(proto: "start_time_unix_nano"),
    8: .standard(proto: "end_time_unix_nano"),
    9: .same(proto: "attributes"),
    10: .standard(proto: "dropped_attributes_count"),
    11: .same(proto: "events"),
    12: .standard(proto: "dropped_events_count"),
    13: .same(proto: "links"),
    14: .standard(proto: "dropped_links_count"),
    15: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _traceID: Data = Data()
    var _spanID: Data = Data()
    var _traceState: String = String()
    var _parentSpanID: Data = Data()
    var _flags: UInt32 = 0
    var _name: String = String()
    var _kind: Opentelemetry_Proto_Trace_V1_Span.SpanKind = .unspecified
    var _startTimeUnixNano: UInt64 = 0
    var _endTimeUnixNano: UInt64 = 0
    var _attributes: [Opentelemetry_Proto_Common_V1_KeyValue] = []
    var _droppedAttributesCount: UInt32 = 0
    var _events: [Opentelemetry_Proto_Trace_V1_Span.Event] = []
    var _droppedEventsCount: UInt32 = 0
    var _links: [Opentelemetry_Proto_Trace_V1_Span.Link] = []
    var _droppedLinksCount: UInt32 = 0
    var _status: Opentelemetry_Proto_Trace_V1_Status? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _traceID = source._traceID
      _spanID = source._spanID
      _traceState = source._traceState
      _parentSpanID = source._parentSpanID
      _flags = source._flags
      _name = source._name
      _kind = source._kind
      _startTimeUnixNano = source._startTimeUnixNano
      _endTimeUnixNano = source._endTimeUnixNano
      _attributes = source._attributes
      _droppedAttributesCount = source._droppedAttributesCount
      _events = source._events
      _droppedEventsCount = source._droppedEventsCount
      _links = source._links
      _droppedLinksCount = source._droppedLinksCount
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._traceID) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._spanID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._traceState) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._parentSpanID) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._kind) }()
        case 7: try { try decoder.decodeSingularFixed64Field(value: &_storage._startTimeUnixNano) }()
        case 8: try { try decoder.decodeSingularFixed64Field(value: &_storage._endTimeUnixNano) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._attributes) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._droppedAttributesCount) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._events) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._droppedEventsCount) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._links) }()
        case 14: try { try decoder.decodeSingularUInt32Field(value: &_storage._droppedLinksCount) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 16: try { try decoder.decodeSingularFixed32Field(value: &_storage._flags) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._traceID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._traceID, fieldNumber: 1)
      }
      if !_storage._spanID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._spanID, fieldNumber: 2)
      }
      if !_storage._traceState.isEmpty {
        try visitor.visitSingularStringField(value: _storage._traceState, fieldNumber: 3)
      }
      if !_storage._parentSpanID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._parentSpanID, fieldNumber: 4)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 5)
      }
      if _storage._kind != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._kind, fieldNumber: 6)
      }
      if _storage._startTimeUnixNano != 0 {
        try visitor.visitSingularFixed64Field(value: _storage._startTimeUnixNano, fieldNumber: 7)
      }
      if _storage._endTimeUnixNano != 0 {
        try visitor.visitSingularFixed64Field(value: _storage._endTimeUnixNano, fieldNumber: 8)
      }
      if !_storage._attributes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._attributes, fieldNumber: 9)
      }
      if _storage._droppedAttributesCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._droppedAttributesCount, fieldNumber: 10)
      }
      if !_storage._events.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._events, fieldNumber: 11)
      }
      if _storage._droppedEventsCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._droppedEventsCount, fieldNumber: 12)
      }
      if !_storage._links.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._links, fieldNumber: 13)
      }
      if _storage._droppedLinksCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._droppedLinksCount, fieldNumber: 14)
      }
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if _storage._flags != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._flags, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Trace_V1_Span, rhs: Opentelemetry_Proto_Trace_V1_Span) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._traceID != rhs_storage._traceID {return false}
        if _storage._spanID != rhs_storage._spanID {return false}
        if _storage._traceState != rhs_storage._traceState {return false}
        if _storage._parentSpanID != rhs_storage._parentSpanID {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._startTimeUnixNano != rhs_storage._startTimeUnixNano {return false}
        if _storage._endTimeUnixNano != rhs_storage._endTimeUnixNano {return false}
        if _storage._attributes != rhs_storage._attributes {return false}
        if _storage._droppedAttributesCount != rhs_storage._droppedAttributesCount {return false}
        if _storage._events != rhs_storage._events {return false}
        if _storage._droppedEventsCount != rhs_storage._droppedEventsCount {return false}
        if _storage._links != rhs_storage._links {return false}
        if _storage._droppedLinksCount != rhs_storage._droppedLinksCount {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Trace_V1_Span.SpanKind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SPAN_KIND_UNSPECIFIED"),
    1: .same(proto: "SPAN_KIND_INTERNAL"),
    2: .same(proto: "SPAN_KIND_SERVER"),
    3: .same(proto: "SPAN_KIND_CLIENT"),
    4: .same(proto: "SPAN_KIND_PRODUCER"),
    5: .same(proto: "SPAN_KIND_CONSUMER"),
  ]
}

extension Opentelemetry_Proto_Trace_V1_Span.Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opentelemetry_Proto_Trace_V1_Span.protoMessageName + ".Event"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_unix_nano"),
    2: .same(proto: "name"),
    3: .same(proto: "attributes"),
    4: .standard(proto: "dropped_attributes_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.attributes) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.droppedAttributesCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.attributes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attributes, fieldNumber: 3)
    }
    if self.droppedAttributesCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.droppedAttributesCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Trace_V1_Span.Event, rhs: Opentelemetry_Proto_Trace_V1_Span.Event) -> Bool {
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.name != rhs.name {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.droppedAttributesCount != rhs.droppedAttributesCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Trace_V1_Span.Link: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opentelemetry_Proto_Trace_V1_Span.protoMessageName + ".Link"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trace_id"),
    2: .standard(proto: "span_id"),
    3: .standard(proto: "trace_state"),
    4: .same(proto: "attributes"),
    5: .standard(proto: "dropped_attributes_count"),
    6: .same(proto: "flags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.traceID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.spanID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.traceState) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.attributes) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.droppedAttributesCount) }()
      case 6: try { try decoder.decodeSingularFixed32Field(value: &self.flags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.traceID.isEmpty {
      try visitor.visitSingularBytesField(value: self.traceID, fieldNumber: 1)
    }
    if !self.spanID.isEmpty {
      try visitor.visitSingularBytesField(value: self.spanID, fieldNumber: 2)
    }
    if !self.traceState.isEmpty {
      try visitor.visitSingularStringField(value: self.traceState, fieldNumber: 3)
    }
    if !self.attributes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attributes, fieldNumber: 4)
    }
    if self.droppedAttributesCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.droppedAttributesCount, fieldNumber: 5)
    }
    if self.flags != 0 {
      try visitor.visitSingularFixed32Field(value: self.flags, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Trace_V1_Span.Link, rhs: Opentelemetry_Proto_Trace_V1_Span.Link) -> Bool {
    if lhs.traceID != rhs.traceID {return false}
    if lhs.spanID != rhs.spanID {return false}
    if lhs.traceState != rhs.traceState {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.droppedAttributesCount != rhs.droppedAttributesCount {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Trace_V1_Status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Status"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "message"),
    3: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.code != .unset {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Trace_V1_Status, rhs: Opentelemetry_Proto_Trace_V1_Status) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Trace_V1_Status.StatusCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_CODE_UNSET"),
    1: .same(proto: "STATUS_CODE_OK"),
    2: .same(proto: "STATUS_CODE_ERROR"),
  ]
}
