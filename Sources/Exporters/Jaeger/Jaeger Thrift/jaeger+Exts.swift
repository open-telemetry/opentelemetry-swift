/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#if !os(watchOS) && !os(visionOS)

  import Foundation

  import Thrift

  public func == (lhs: Tag, rhs: Tag) -> Bool {
    return
      (lhs.key == rhs.key) && (lhs.vType == rhs.vType) && (lhs.vStr == rhs.vStr)
        && (lhs.vDouble == rhs.vDouble) && (lhs.vBool == rhs.vBool)
        && (lhs.vLong == rhs.vLong) && (lhs.vBinary == rhs.vBinary)
  }

  extension Tag: CustomStringConvertible {
    public var description: String {
      var desc = "Tag("
      desc += "key=\(String(describing: key)), "
      desc += "vType=\(String(describing: vType)), "
      desc += "vStr=\(String(describing: vStr)), "
      desc += "vDouble=\(String(describing: vDouble)), "
      desc += "vBool=\(String(describing: vBool)), "
      desc += "vLong=\(String(describing: vLong)), "
      desc += "vBinary=\(String(describing: vBinary))"
      return desc
    }
  }

  extension Tag: Hashable {
    public func hash(into hasher: inout Hasher) {
      hasher.combine(key)
      hasher.combine(vType)
      hasher.combine(vStr)
      hasher.combine(vDouble)
      hasher.combine(vBool)
      hasher.combine(vLong)
      hasher.combine(vBinary)
    }
  }

  extension Tag: TStruct {
    public static var fieldIds: [String: Int32] {
      return [
        "key": 1, "vType": 2, "vStr": 3, "vDouble": 4, "vBool": 5, "vLong": 6,
        "vBinary": 7
      ]
    }

    public static var structName: String { return "Tag" }

    public static func read(from proto: TProtocol) throws -> Tag {
      _ = try proto.readStructBegin()
      var key: String!
      var vType: TagType!
      var vStr: String?
      var vDouble: Double?
      var vBool: Bool?
      var vLong: Int64?
      var vBinary: Data?

      fields: while true {
        let (_, fieldType, fieldID) = try proto.readFieldBegin()

        switch (fieldID, fieldType) {
        case (_, .stop): break fields
        case (1, .string): key = try String.read(from: proto)
        case (2, .i32): vType = try TagType.read(from: proto)
        case (3, .string): vStr = try String.read(from: proto)
        case (4, .double): vDouble = try Double.read(from: proto)
        case (5, .bool): vBool = try Bool.read(from: proto)
        case (6, .i64): vLong = try Int64.read(from: proto)
        case (7, .string): vBinary = try Data.read(from: proto)
        case let (_, unknownType): try proto.skip(type: unknownType)
        }

        try proto.readFieldEnd()
      }

      try proto.readStructEnd()
      // Required fields
      try proto.validateValue(key, named: "key")
      try proto.validateValue(vType, named: "vType")

      return Tag(key: key, vType: vType, vStr: vStr, vDouble: vDouble, vBool: vBool,
                 vLong: vLong, vBinary: vBinary)
    }
  }

  public func == (lhs: Log, rhs: Log) -> Bool {
    return
      (lhs.timestamp == rhs.timestamp) && (lhs.fields == rhs.fields)
  }

  extension Log: CustomStringConvertible {
    public var description: String {
      var desc = "Log("
      desc += "timestamp=\(String(describing: timestamp)), "
      desc += "fields=\(String(describing: fields))"
      return desc
    }
  }

  extension Log: Hashable {
    public func hash(into hasher: inout Hasher) {
      hasher.combine(timestamp)
      hasher.combine(fields)
    }
  }

  extension Log: TStruct {
    public static var fieldIds: [String: Int32] {
      return ["timestamp": 1, "fields": 2]
    }

    public static var structName: String { return "Log" }

    public static func read(from proto: TProtocol) throws -> Log {
      _ = try proto.readStructBegin()
      var timestamp: Int64!
      var fields: TList<Tag>!

      fields: while true {
        let (_, fieldType, fieldID) = try proto.readFieldBegin()

        switch (fieldID, fieldType) {
        case (_, .stop): break fields
        case (1, .i64): timestamp = try Int64.read(from: proto)
        case (2, .list): fields = try TList<Tag>.read(from: proto)
        case let (_, unknownType): try proto.skip(type: unknownType)
        }

        try proto.readFieldEnd()
      }

      try proto.readStructEnd()
      // Required fields
      try proto.validateValue(timestamp, named: "timestamp")
      try proto.validateValue(fields, named: "fields")

      return Log(timestamp: timestamp, fields: fields)
    }
  }

  public func == (lhs: SpanRef, rhs: SpanRef) -> Bool {
    return
      (lhs.refType == rhs.refType) && (lhs.traceIdLow == rhs.traceIdLow)
        && (lhs.traceIdHigh == rhs.traceIdHigh) && (lhs.spanId == rhs.spanId)
  }

  extension SpanRef: CustomStringConvertible {
    public var description: String {
      var desc = "SpanRef("
      desc += "refType=\(String(describing: refType)), "
      desc += "traceIdLow=\(String(describing: traceIdLow)), "
      desc += "traceIdHigh=\(String(describing: traceIdHigh)), "
      desc += "spanId=\(String(describing: spanId))"
      return desc
    }
  }

  extension SpanRef: Hashable {
    public func hash(into hasher: inout Hasher) {
      hasher.combine(refType)
      hasher.combine(traceIdLow)
      hasher.combine(traceIdHigh)
      hasher.combine(spanId)
    }
  }

  extension SpanRef: TStruct {
    public static var fieldIds: [String: Int32] {
      return ["refType": 1, "traceIdLow": 2, "traceIdHigh": 3, "spanId": 4]
    }

    public static var structName: String { return "SpanRef" }

    public static func read(from proto: TProtocol) throws -> SpanRef {
      _ = try proto.readStructBegin()
      var refType: SpanRefType!
      var traceIdLow: Int64!
      var traceIdHigh: Int64!
      var spanId: Int64!

      fields: while true {
        let (_, fieldType, fieldID) = try proto.readFieldBegin()

        switch (fieldID, fieldType) {
        case (_, .stop): break fields
        case (1, .i32): refType = try SpanRefType.read(from: proto)
        case (2, .i64): traceIdLow = try Int64.read(from: proto)
        case (3, .i64): traceIdHigh = try Int64.read(from: proto)
        case (4, .i64): spanId = try Int64.read(from: proto)
        case let (_, unknownType): try proto.skip(type: unknownType)
        }

        try proto.readFieldEnd()
      }

      try proto.readStructEnd()
      // Required fields
      try proto.validateValue(refType, named: "refType")
      try proto.validateValue(traceIdLow, named: "traceIdLow")
      try proto.validateValue(traceIdHigh, named: "traceIdHigh")
      try proto.validateValue(spanId, named: "spanId")

      return SpanRef(refType: refType, traceIdLow: traceIdLow, traceIdHigh: traceIdHigh,
                     spanId: spanId)
    }
  }

  public func == (lhs: Span, rhs: Span) -> Bool {
    return
      (lhs.traceIdLow == rhs.traceIdLow) && (lhs.traceIdHigh == rhs.traceIdHigh)
        && (lhs.spanId == rhs.spanId) && (lhs.parentSpanId == rhs.parentSpanId)
        && (lhs.operationName == rhs.operationName)
        && (lhs.references == rhs.references) && (lhs.flags == rhs.flags)
        && (lhs.startTime == rhs.startTime) && (lhs.duration == rhs.duration)
        && (lhs.tags == rhs.tags) && (lhs.logs == rhs.logs)
  }

  extension Span: CustomStringConvertible {
    public var description: String {
      var desc = "Span("
      desc += "traceIdLow=\(String(describing: traceIdLow)), "
      desc += "traceIdHigh=\(String(describing: traceIdHigh)), "
      desc += "spanId=\(String(describing: spanId)), "
      desc += "parentSpanId=\(String(describing: parentSpanId)), "
      desc += "operationName=\(String(describing: operationName)), "
      desc += "references=\(String(describing: references)), "
      desc += "flags=\(String(describing: flags)), "
      desc += "startTime=\(String(describing: startTime)), "
      desc += "duration=\(String(describing: duration)), "
      desc += "tags=\(String(describing: tags)), "
      desc += "logs=\(String(describing: logs))"
      return desc
    }
  }

  extension Span: Hashable {
    public func hash(into hasher: inout Hasher) {
      hasher.combine(traceIdLow)
      hasher.combine(traceIdHigh)
      hasher.combine(spanId)
      hasher.combine(parentSpanId)
      hasher.combine(operationName)
      hasher.combine(references)
      hasher.combine(flags)
      hasher.combine(startTime)
      hasher.combine(duration)
      hasher.combine(tags)
      hasher.combine(logs)
    }
  }

  extension Span: TStruct {
    public static var fieldIds: [String: Int32] {
      return [
        "traceIdLow": 1, "traceIdHigh": 2, "spanId": 3, "parentSpanId": 4,
        "operationName": 5, "references": 6, "flags": 7, "startTime": 8,
        "duration": 9, "tags": 10, "logs": 11
      ]
    }

    public static var structName: String { return "Span" }

    public static func read(from proto: TProtocol) throws -> Span {
      _ = try proto.readStructBegin()
      var traceIdLow: Int64!
      var traceIdHigh: Int64!
      var spanId: Int64!
      var parentSpanId: Int64!
      var operationName: String!
      var references: TList<SpanRef>?
      var flags: Int32!
      var startTime: Int64!
      var duration: Int64!
      var tags: TList<Tag>?
      var logs: TList<Log>?

      fields: while true {
        let (_, fieldType, fieldID) = try proto.readFieldBegin()

        switch (fieldID, fieldType) {
        case (_, .stop): break fields
        case (1, .i64): traceIdLow = try Int64.read(from: proto)
        case (2, .i64): traceIdHigh = try Int64.read(from: proto)
        case (3, .i64): spanId = try Int64.read(from: proto)
        case (4, .i64): parentSpanId = try Int64.read(from: proto)
        case (5, .string): operationName = try String.read(from: proto)
        case (6, .list): references = try TList<SpanRef>.read(from: proto)
        case (7, .i32): flags = try Int32.read(from: proto)
        case (8, .i64): startTime = try Int64.read(from: proto)
        case (9, .i64): duration = try Int64.read(from: proto)
        case (10, .list): tags = try TList<Tag>.read(from: proto)
        case (11, .list): logs = try TList<Log>.read(from: proto)
        case let (_, unknownType): try proto.skip(type: unknownType)
        }

        try proto.readFieldEnd()
      }

      try proto.readStructEnd()
      // Required fields
      try proto.validateValue(traceIdLow, named: "traceIdLow")
      try proto.validateValue(traceIdHigh, named: "traceIdHigh")
      try proto.validateValue(spanId, named: "spanId")
      try proto.validateValue(parentSpanId, named: "parentSpanId")
      try proto.validateValue(operationName, named: "operationName")
      try proto.validateValue(flags, named: "flags")
      try proto.validateValue(startTime, named: "startTime")
      try proto.validateValue(duration, named: "duration")

      return Span(traceIdLow: traceIdLow, traceIdHigh: traceIdHigh, spanId: spanId,
                  parentSpanId: parentSpanId, operationName: operationName,
                  references: references, flags: flags, startTime: startTime,
                  duration: duration, tags: tags, logs: logs)
    }
  }

  public func == (lhs: Process, rhs: Process) -> Bool {
    return
      (lhs.serviceName == rhs.serviceName) && (lhs.tags == rhs.tags)
  }

  extension Process: CustomStringConvertible {
    public var description: String {
      var desc = "Process("
      desc += "serviceName=\(String(describing: serviceName)), "
      desc += "tags=\(String(describing: tags))"
      return desc
    }
  }

  extension Process: Hashable {
    public func hash(into hasher: inout Hasher) {
      hasher.combine(serviceName)
      hasher.combine(tags)
    }
  }

  extension Process: TStruct {
    public static var fieldIds: [String: Int32] {
      return ["serviceName": 1, "tags": 2]
    }

    public static var structName: String { return "Process" }

    public static func read(from proto: TProtocol) throws -> Process {
      _ = try proto.readStructBegin()
      var serviceName: String!
      var tags: TList<Tag>?

      fields: while true {
        let (_, fieldType, fieldID) = try proto.readFieldBegin()

        switch (fieldID, fieldType) {
        case (_, .stop): break fields
        case (1, .string): serviceName = try String.read(from: proto)
        case (2, .list): tags = try TList<Tag>.read(from: proto)
        case let (_, unknownType): try proto.skip(type: unknownType)
        }

        try proto.readFieldEnd()
      }

      try proto.readStructEnd()
      // Required fields
      try proto.validateValue(serviceName, named: "serviceName")

      return Process(serviceName: serviceName, tags: tags)
    }
  }

  public func == (lhs: Batch, rhs: Batch) -> Bool {
    return
      (lhs.process == rhs.process) && (lhs.spans == rhs.spans)
  }

  extension Batch: CustomStringConvertible {
    public var description: String {
      var desc = "Batch("
      desc += "process=\(String(describing: process)), "
      desc += "spans=\(String(describing: spans))"
      return desc
    }
  }

  extension Batch: Hashable {
    public func hash(into hasher: inout Hasher) {
      hasher.combine(process)
      hasher.combine(spans)
    }
  }

  extension Batch: TStruct {
    public static var fieldIds: [String: Int32] {
      return ["process": 1, "spans": 2]
    }

    public static var structName: String { return "Batch" }

    public static func read(from proto: TProtocol) throws -> Batch {
      _ = try proto.readStructBegin()
      var process: Process!
      var spans: TList<Span>!

      fields: while true {
        let (_, fieldType, fieldID) = try proto.readFieldBegin()

        switch (fieldID, fieldType) {
        case (_, .stop): break fields
        case (1, .struct): process = try Process.read(from: proto)
        case (2, .list): spans = try TList<Span>.read(from: proto)
        case let (_, unknownType): try proto.skip(type: unknownType)
        }

        try proto.readFieldEnd()
      }

      try proto.readStructEnd()
      // Required fields
      try proto.validateValue(process, named: "process")
      try proto.validateValue(spans, named: "spans")

      return Batch(process: process, spans: spans)
    }
  }

  public func == (lhs: BatchSubmitResponse, rhs: BatchSubmitResponse) -> Bool {
    return
      lhs.ok == rhs.ok
  }

  extension BatchSubmitResponse: CustomStringConvertible {
    public var description: String {
      var desc = "BatchSubmitResponse("
      desc += "ok=\(String(describing: ok))"
      return desc
    }
  }

  extension BatchSubmitResponse: Hashable {
    public func hash(into hasher: inout Hasher) {
      hasher.combine(ok)
    }
  }

  extension BatchSubmitResponse: TStruct {
    public static var fieldIds: [String: Int32] {
      return ["ok": 1]
    }

    public static var structName: String { return "BatchSubmitResponse" }

    public static func read(from proto: TProtocol) throws -> BatchSubmitResponse {
      _ = try proto.readStructBegin()
      var ok: Bool!

      fields: while true {
        let (_, fieldType, fieldID) = try proto.readFieldBegin()

        switch (fieldID, fieldType) {
        case (_, .stop): break fields
        case (1, .bool): ok = try Bool.read(from: proto)
        case let (_, unknownType): try proto.skip(type: unknownType)
        }

        try proto.readFieldEnd()
      }

      try proto.readStructEnd()
      // Required fields
      try proto.validateValue(ok, named: "ok")

      return BatchSubmitResponse(ok: ok)
    }
  }

  private final class Collector_submitBatches_args {
    fileprivate var batches: TList<Batch>

    fileprivate init(batches: TList<Batch>) {
      self.batches = batches
    }
  }

  private func == (lhs: Collector_submitBatches_args, rhs: Collector_submitBatches_args) -> Bool {
    return
      lhs.batches == rhs.batches
  }

  extension Collector_submitBatches_args: Hashable {
    func hash(into hasher: inout Hasher) {
      hasher.combine(batches)
    }
  }

  extension Collector_submitBatches_args: TStruct {
    fileprivate static var fieldIds: [String: Int32] {
      return ["batches": 1]
    }

    fileprivate static var structName: String {
      return "Collector_submitBatches_args"
    }

    fileprivate static func read(from proto: TProtocol) throws
      -> Collector_submitBatches_args {
      _ = try proto.readStructBegin()
      var batches: TList<Batch>!

      fields: while true {
        let (_, fieldType, fieldID) = try proto.readFieldBegin()

        switch (fieldID, fieldType) {
        case (_, .stop): break fields
        case (1, .list): batches = try TList<Batch>.read(from: proto)
        case let (_, unknownType): try proto.skip(type: unknownType)
        }

        try proto.readFieldEnd()
      }

      try proto.readStructEnd()
      // Required fields
      try proto.validateValue(batches, named: "batches")

      return Collector_submitBatches_args(batches: batches)
    }
  }

  private final class Collector_submitBatches_result {
    fileprivate var success: TList<BatchSubmitResponse>?

    fileprivate init() {}
    fileprivate init(success: TList<BatchSubmitResponse>?) {
      self.success = success
    }
  }

  private func == (lhs: Collector_submitBatches_result, rhs: Collector_submitBatches_result) -> Bool {
    return
      lhs.success == rhs.success
  }

  extension Collector_submitBatches_result: Hashable {
    func hash(into hasher: inout Hasher) {
      hasher.combine(success)
    }
  }

  extension Collector_submitBatches_result: TStruct {
    fileprivate static var fieldIds: [String: Int32] {
      return ["success": 0]
    }

    fileprivate static var structName: String {
      return "Collector_submitBatches_result"
    }

    fileprivate static func read(from proto: TProtocol) throws
      -> Collector_submitBatches_result {
      _ = try proto.readStructBegin()
      var success: TList<BatchSubmitResponse>?

      fields: while true {
        let (_, fieldType, fieldID) = try proto.readFieldBegin()

        switch (fieldID, fieldType) {
        case (_, .stop): break fields
        case (0, .list):
          success = try TList<BatchSubmitResponse>.read(from: proto)
        case let (_, unknownType): try proto.skip(type: unknownType)
        }

        try proto.readFieldEnd()
      }

      try proto.readStructEnd()

      return Collector_submitBatches_result(success: success)
    }
  }

  extension CollectorClient: Collector {
    private func send_submitBatches(batches: TList<Batch>) throws {
      try outProtocol.writeMessageBegin(name: "submitBatches", type: .call, sequenceID: 0)
      let args = Collector_submitBatches_args(batches: batches)
      try args.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }

    private func recv_submitBatches() throws -> TList<BatchSubmitResponse> {
      try inProtocol.readResultMessageBegin()
      let result = try Collector_submitBatches_result.read(from: inProtocol)
      try inProtocol.readMessageEnd()

      if let success = result.success {
        return success
      }
      throw TApplicationError(
        error: .missingResult(methodName: "submitBatches"))
    }

    public func submitBatches(batches: TList<Batch>) throws -> TList<BatchSubmitResponse> {
      try send_submitBatches(batches: batches)
      try outProtocol.transport.flush()
      return try recv_submitBatches()
    }
  }

  extension CollectorAsyncClient: CollectorAsync {
    private func send_submitBatches(on outProtocol: TProtocol, batches: TList<Batch>) throws {
      try outProtocol.writeMessageBegin(name: "submitBatches", type: .call, sequenceID: 0)
      let args = Collector_submitBatches_args(batches: batches)
      try args.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }

    private func recv_submitBatches(on inProtocol: TProtocol) throws -> TList<BatchSubmitResponse> {
      try inProtocol.readResultMessageBegin()
      let result = try Collector_submitBatches_result.read(from: inProtocol)
      try inProtocol.readMessageEnd()

      if let success = result.success {
        return success
      }
      throw TApplicationError(
        error: .missingResult(methodName: "submitBatches"))
    }

    public func submitBatches(batches: TList<Batch>,
                              completion: @escaping (TAsyncResult<TList<BatchSubmitResponse>>) -> Void) {
      let transport = factory.newTransport()
      let proto = Protocol(on: transport)

      do {
        try send_submitBatches(on: proto, batches: batches)
      } catch {
        completion(.error(error))
      }

      transport.flush { _, error in
        if let error {
          completion(.error(error))
        }
        do {
          let result = try self.recv_submitBatches(on: proto)
          completion(.success(result))
        } catch {
          completion(.error(error))
        }
      }
    }
  }

  extension CollectorProcessor: TProcessor {
    static let processorHandlers: ProcessorHandlerDictionary = {
      var processorHandlers = ProcessorHandlerDictionary()

      processorHandlers["submitBatches"] = { sequenceID, inProtocol, outProtocol, handler in

        let args = try Collector_submitBatches_args.read(from: inProtocol)

        try inProtocol.readMessageEnd()

        var result = Collector_submitBatches_result()
        do {
          result.success = try handler.submitBatches(batches: args.batches)
        } catch { throw error }

        try outProtocol.writeMessageBegin(name: "submitBatches", type: .reply, sequenceID: sequenceID)
        try result.write(to: outProtocol)
        try outProtocol.writeMessageEnd()
      }
      return processorHandlers
    }()

    public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {
      let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

      if let processorHandler = CollectorProcessor.processorHandlers[
        messageName
      ] {
        do {
          try processorHandler(sequenceID, inProtocol, outProtocol, service)
        } catch let error as TApplicationError {
          try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
        }
      } else {
        try inProtocol.skip(type: .struct)
        try inProtocol.readMessageEnd()
        let ex = TApplicationError(
          error: .unknownMethod(methodName: messageName))
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
      }
    }
  }

#endif
