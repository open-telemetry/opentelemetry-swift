/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public func ==(lhs: Tag, rhs: Tag) -> Bool {
  return
    (lhs.key == rhs.key) &&
    (lhs.vType == rhs.vType) &&
    (lhs.vStr == rhs.vStr) &&
    (lhs.vDouble == rhs.vDouble) &&
    (lhs.vBool == rhs.vBool) &&
    (lhs.vLong == rhs.vLong) &&
    (lhs.vBinary == rhs.vBinary)
}

extension Tag : CustomStringConvertible {

  public var description : String {
    var desc = "Tag("
    desc += "key=\(String(describing: self.key)), "
    desc += "vType=\(String(describing: self.vType)), "
    desc += "vStr=\(String(describing: self.vStr)), "
    desc += "vDouble=\(String(describing: self.vDouble)), "
    desc += "vBool=\(String(describing: self.vBool)), "
    desc += "vLong=\(String(describing: self.vLong)), "
    desc += "vBinary=\(String(describing: self.vBinary))"
    return desc
  }

}

extension Tag : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (key.hashValue)
    result = prime &* result &+ (vType.hashValue)
    result = prime &* result &+ (vStr?.hashValue ?? 0)
    result = prime &* result &+ (vDouble?.hashValue ?? 0)
    result = prime &* result &+ (vBool?.hashValue ?? 0)
    result = prime &* result &+ (vLong?.hashValue ?? 0)
    result = prime &* result &+ (vBinary?.hashValue ?? 0)
    return result
  }

}

extension Tag : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["key": 1, "vType": 2, "vStr": 3, "vDouble": 4, "vBool": 5, "vLong": 6, "vBinary": 7, ]
  }

  public static var structName: String { return "Tag" }

  public static func read(from proto: TProtocol) throws -> Tag {
    _ = try proto.readStructBegin()
    var key: String!
    var vType: TagType!
    var vStr: String?
    var vDouble: Double?
    var vBool: Bool?
    var vLong: Int64?
    var vBinary: Data?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           key = try String.read(from: proto)
        case (2, .i32):             vType = try TagType.read(from: proto)
        case (3, .string):           vStr = try String.read(from: proto)
        case (4, .double):           vDouble = try Double.read(from: proto)
        case (5, .bool):            vBool = try Bool.read(from: proto)
        case (6, .i64):             vLong = try Int64.read(from: proto)
        case (7, .string):           vBinary = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(key, named: "key")
    try proto.validateValue(vType, named: "vType")

    return Tag(key: key, vType: vType, vStr: vStr, vDouble: vDouble, vBool: vBool, vLong: vLong, vBinary: vBinary)
  }

}



public func ==(lhs: Log, rhs: Log) -> Bool {
  return
    (lhs.timestamp == rhs.timestamp) &&
    (lhs.fields == rhs.fields)
}

extension Log : CustomStringConvertible {

  public var description : String {
    var desc = "Log("
    desc += "timestamp=\(String(describing: self.timestamp)), "
    desc += "fields=\(String(describing: self.fields))"
    return desc
  }

}

extension Log : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (timestamp.hashValue)
    result = prime &* result &+ (fields.hashValue)
    return result
  }

}

extension Log : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["timestamp": 1, "fields": 2, ]
  }

  public static var structName: String { return "Log" }

  public static func read(from proto: TProtocol) throws -> Log {
    _ = try proto.readStructBegin()
    var timestamp: Int64!
    var fields: TList<Tag>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i64):             timestamp = try Int64.read(from: proto)
        case (2, .list):            fields = try TList<Tag>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(timestamp, named: "timestamp")
    try proto.validateValue(fields, named: "fields")

    return Log(timestamp: timestamp, fields: fields)
  }

}



public func ==(lhs: SpanRef, rhs: SpanRef) -> Bool {
  return
    (lhs.refType == rhs.refType) &&
    (lhs.traceIdLow == rhs.traceIdLow) &&
    (lhs.traceIdHigh == rhs.traceIdHigh) &&
    (lhs.spanId == rhs.spanId)
}

extension SpanRef : CustomStringConvertible {

  public var description : String {
    var desc = "SpanRef("
    desc += "refType=\(String(describing: self.refType)), "
    desc += "traceIdLow=\(String(describing: self.traceIdLow)), "
    desc += "traceIdHigh=\(String(describing: self.traceIdHigh)), "
    desc += "spanId=\(String(describing: self.spanId))"
    return desc
  }

}

extension SpanRef : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (refType.hashValue)
    result = prime &* result &+ (traceIdLow.hashValue)
    result = prime &* result &+ (traceIdHigh.hashValue)
    result = prime &* result &+ (spanId.hashValue)
    return result
  }

}

extension SpanRef : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["refType": 1, "traceIdLow": 2, "traceIdHigh": 3, "spanId": 4, ]
  }

  public static var structName: String { return "SpanRef" }

  public static func read(from proto: TProtocol) throws -> SpanRef {
    _ = try proto.readStructBegin()
    var refType: SpanRefType!
    var traceIdLow: Int64!
    var traceIdHigh: Int64!
    var spanId: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             refType = try SpanRefType.read(from: proto)
        case (2, .i64):             traceIdLow = try Int64.read(from: proto)
        case (3, .i64):             traceIdHigh = try Int64.read(from: proto)
        case (4, .i64):             spanId = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(refType, named: "refType")
    try proto.validateValue(traceIdLow, named: "traceIdLow")
    try proto.validateValue(traceIdHigh, named: "traceIdHigh")
    try proto.validateValue(spanId, named: "spanId")

    return SpanRef(refType: refType, traceIdLow: traceIdLow, traceIdHigh: traceIdHigh, spanId: spanId)
  }

}



public func ==(lhs: Span, rhs: Span) -> Bool {
  return
    (lhs.traceIdLow == rhs.traceIdLow) &&
    (lhs.traceIdHigh == rhs.traceIdHigh) &&
    (lhs.spanId == rhs.spanId) &&
    (lhs.parentSpanId == rhs.parentSpanId) &&
    (lhs.operationName == rhs.operationName) &&
    (lhs.references == rhs.references) &&
    (lhs.flags == rhs.flags) &&
    (lhs.startTime == rhs.startTime) &&
    (lhs.duration == rhs.duration) &&
    (lhs.tags == rhs.tags) &&
    (lhs.logs == rhs.logs)
}

extension Span : CustomStringConvertible {

  public var description : String {
    var desc = "Span("
    desc += "traceIdLow=\(String(describing: self.traceIdLow)), "
    desc += "traceIdHigh=\(String(describing: self.traceIdHigh)), "
    desc += "spanId=\(String(describing: self.spanId)), "
    desc += "parentSpanId=\(String(describing: self.parentSpanId)), "
    desc += "operationName=\(String(describing: self.operationName)), "
    desc += "references=\(String(describing: self.references)), "
    desc += "flags=\(String(describing: self.flags)), "
    desc += "startTime=\(String(describing: self.startTime)), "
    desc += "duration=\(String(describing: self.duration)), "
    desc += "tags=\(String(describing: self.tags)), "
    desc += "logs=\(String(describing: self.logs))"
    return desc
  }

}

extension Span : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (traceIdLow.hashValue)
    result = prime &* result &+ (traceIdHigh.hashValue)
    result = prime &* result &+ (spanId.hashValue)
    result = prime &* result &+ (parentSpanId.hashValue)
    result = prime &* result &+ (operationName.hashValue)
    result = prime &* result &+ (references?.hashValue ?? 0)
    result = prime &* result &+ (flags.hashValue)
    result = prime &* result &+ (startTime.hashValue)
    result = prime &* result &+ (duration.hashValue)
    result = prime &* result &+ (tags?.hashValue ?? 0)
    result = prime &* result &+ (logs?.hashValue ?? 0)
    return result
  }

}

extension Span : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["traceIdLow": 1, "traceIdHigh": 2, "spanId": 3, "parentSpanId": 4, "operationName": 5, "references": 6, "flags": 7, "startTime": 8, "duration": 9, "tags": 10, "logs": 11, ]
  }

  public static var structName: String { return "Span" }

  public static func read(from proto: TProtocol) throws -> Span {
    _ = try proto.readStructBegin()
    var traceIdLow: Int64!
    var traceIdHigh: Int64!
    var spanId: Int64!
    var parentSpanId: Int64!
    var operationName: String!
    var references: TList<SpanRef>?
    var flags: Int32!
    var startTime: Int64!
    var duration: Int64!
    var tags: TList<Tag>?
    var logs: TList<Log>?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i64):             traceIdLow = try Int64.read(from: proto)
        case (2, .i64):             traceIdHigh = try Int64.read(from: proto)
        case (3, .i64):             spanId = try Int64.read(from: proto)
        case (4, .i64):             parentSpanId = try Int64.read(from: proto)
        case (5, .string):           operationName = try String.read(from: proto)
        case (6, .list):            references = try TList<SpanRef>.read(from: proto)
        case (7, .i32):             flags = try Int32.read(from: proto)
        case (8, .i64):             startTime = try Int64.read(from: proto)
        case (9, .i64):             duration = try Int64.read(from: proto)
        case (10, .list):            tags = try TList<Tag>.read(from: proto)
        case (11, .list):            logs = try TList<Log>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(traceIdLow, named: "traceIdLow")
    try proto.validateValue(traceIdHigh, named: "traceIdHigh")
    try proto.validateValue(spanId, named: "spanId")
    try proto.validateValue(parentSpanId, named: "parentSpanId")
    try proto.validateValue(operationName, named: "operationName")
    try proto.validateValue(flags, named: "flags")
    try proto.validateValue(startTime, named: "startTime")
    try proto.validateValue(duration, named: "duration")

    return Span(traceIdLow: traceIdLow, traceIdHigh: traceIdHigh, spanId: spanId, parentSpanId: parentSpanId, operationName: operationName, references: references, flags: flags, startTime: startTime, duration: duration, tags: tags, logs: logs)
  }

}



public func ==(lhs: Process, rhs: Process) -> Bool {
  return
    (lhs.serviceName == rhs.serviceName) &&
    (lhs.tags == rhs.tags)
}

extension Process : CustomStringConvertible {

  public var description : String {
    var desc = "Process("
    desc += "serviceName=\(String(describing: self.serviceName)), "
    desc += "tags=\(String(describing: self.tags))"
    return desc
  }

}

extension Process : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (serviceName.hashValue)
    result = prime &* result &+ (tags?.hashValue ?? 0)
    return result
  }

}

extension Process : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["serviceName": 1, "tags": 2, ]
  }

  public static var structName: String { return "Process" }

  public static func read(from proto: TProtocol) throws -> Process {
    _ = try proto.readStructBegin()
    var serviceName: String!
    var tags: TList<Tag>?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           serviceName = try String.read(from: proto)
        case (2, .list):            tags = try TList<Tag>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(serviceName, named: "serviceName")

    return Process(serviceName: serviceName, tags: tags)
  }

}



public func ==(lhs: Batch, rhs: Batch) -> Bool {
  return
    (lhs.process == rhs.process) &&
    (lhs.spans == rhs.spans)
}

extension Batch : CustomStringConvertible {

  public var description : String {
    var desc = "Batch("
    desc += "process=\(String(describing: self.process)), "
    desc += "spans=\(String(describing: self.spans))"
    return desc
  }

}

extension Batch : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (process.hashValue)
    result = prime &* result &+ (spans.hashValue)
    return result
  }

}

extension Batch : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["process": 1, "spans": 2, ]
  }

  public static var structName: String { return "Batch" }

  public static func read(from proto: TProtocol) throws -> Batch {
    _ = try proto.readStructBegin()
    var process: Process!
    var spans: TList<Span>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           process = try Process.read(from: proto)
        case (2, .list):            spans = try TList<Span>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(process, named: "process")
    try proto.validateValue(spans, named: "spans")

    return Batch(process: process, spans: spans)
  }

}



public func ==(lhs: BatchSubmitResponse, rhs: BatchSubmitResponse) -> Bool {
  return
    (lhs.ok == rhs.ok)
}

extension BatchSubmitResponse : CustomStringConvertible {

  public var description : String {
    var desc = "BatchSubmitResponse("
    desc += "ok=\(String(describing: self.ok))"
    return desc
  }

}

extension BatchSubmitResponse : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (ok.hashValue)
    return result
  }

}

extension BatchSubmitResponse : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["ok": 1, ]
  }

  public static var structName: String { return "BatchSubmitResponse" }

  public static func read(from proto: TProtocol) throws -> BatchSubmitResponse {
    _ = try proto.readStructBegin()
    var ok: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .bool):            ok = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(ok, named: "ok")

    return BatchSubmitResponse(ok: ok)
  }

}



fileprivate final class Collector_submitBatches_args {

  fileprivate var batches: TList<Batch>


  fileprivate init(batches: TList<Batch>) {
    self.batches = batches
  }

}

fileprivate func ==(lhs: Collector_submitBatches_args, rhs: Collector_submitBatches_args) -> Bool {
  return
    (lhs.batches == rhs.batches)
}

extension Collector_submitBatches_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (batches.hashValue)
    return result
  }

}

extension Collector_submitBatches_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["batches": 1, ]
  }

  fileprivate static var structName: String { return "Collector_submitBatches_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Collector_submitBatches_args {
    _ = try proto.readStructBegin()
    var batches: TList<Batch>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            batches = try TList<Batch>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(batches, named: "batches")

    return Collector_submitBatches_args(batches: batches)
  }

}



fileprivate final class Collector_submitBatches_result {

  fileprivate var success: TList<BatchSubmitResponse>?


  fileprivate init() { }
  fileprivate init(success: TList<BatchSubmitResponse>?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Collector_submitBatches_result, rhs: Collector_submitBatches_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Collector_submitBatches_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    return result
  }

}

extension Collector_submitBatches_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Collector_submitBatches_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Collector_submitBatches_result {
    _ = try proto.readStructBegin()
    var success: TList<BatchSubmitResponse>?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<BatchSubmitResponse>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Collector_submitBatches_result(success: success)
  }

}



extension CollectorClient : Collector {

  private func send_submitBatches(batches: TList<Batch>) throws {
    try outProtocol.writeMessageBegin(name: "submitBatches", type: .call, sequenceID: 0)
    let args = Collector_submitBatches_args(batches: batches)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_submitBatches() throws -> TList<BatchSubmitResponse> {
    try inProtocol.readResultMessageBegin() 
    let result = try Collector_submitBatches_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "submitBatches"))
  }

  public func submitBatches(batches: TList<Batch>) throws -> TList<BatchSubmitResponse> {
    try send_submitBatches(batches: batches)
    try outProtocol.transport.flush()
    return try recv_submitBatches()
  }

}

extension CollectorAsyncClient : CollectorAsync {

  private func send_submitBatches(on outProtocol: TProtocol, batches: TList<Batch>) throws {
    try outProtocol.writeMessageBegin(name: "submitBatches", type: .call, sequenceID: 0)
    let args = Collector_submitBatches_args(batches: batches)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_submitBatches(on inProtocol: TProtocol) throws -> TList<BatchSubmitResponse> {
    try inProtocol.readResultMessageBegin() 
    let result = try Collector_submitBatches_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "submitBatches"))
  }

  public func submitBatches(batches: TList<Batch>, completion: @escaping (TAsyncResult<TList<BatchSubmitResponse>>) -> Void) {

    let transport   = factory.newTransport()
    let proto = Protocol(on: transport)

    do {
      try send_submitBatches(on: proto, batches: batches)
    } catch let error {
      completion(.error(error))
    }

    transport.flush {
      (trans, error) in

      if let error = error {
        completion(.error(error))
      }
      do {
        let result = try self.recv_submitBatches(on: proto)
        completion(.success(result))
      } catch let error {
        completion(.error(error))
      }
    }
  }
}

extension CollectorProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["submitBatches"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Collector_submitBatches_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Collector_submitBatches_result()
      do {
        result.success = try handler.submitBatches(batches: args.batches)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "submitBatches", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = CollectorProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

