// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: opentelemetry/proto/metrics/v1/metrics.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// AggregationTemporality defines how a metric aggregator reports aggregated
/// values. It describes how those values relate to the time interval over
/// which they are aggregated.
public enum Opentelemetry_Proto_Metrics_V1_AggregationTemporality: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// UNSPECIFIED is the default AggregationTemporality, it MUST not be used.
  case unspecified // = 0

  /// DELTA is an AggregationTemporality for a metric aggregator which reports
  /// changes since last report time. Successive metrics contain aggregation of
  /// values from continuous and non-overlapping intervals.
  ///
  /// The values for a DELTA metric are based only on the time interval
  /// associated with one measurement cycle. There is no dependency on
  /// previous measurements like is the case for CUMULATIVE metrics.
  ///
  /// For example, consider a system measuring the number of requests that
  /// it receives and reports the sum of these requests every second as a
  /// DELTA metric:
  ///
  ///   1. The system starts receiving at time=t_0.
  ///   2. A request is received, the system measures 1 request.
  ///   3. A request is received, the system measures 1 request.
  ///   4. A request is received, the system measures 1 request.
  ///   5. The 1 second collection cycle ends. A metric is exported for the
  ///      number of requests received over the interval of time t_0 to
  ///      t_0+1 with a value of 3.
  ///   6. A request is received, the system measures 1 request.
  ///   7. A request is received, the system measures 1 request.
  ///   8. The 1 second collection cycle ends. A metric is exported for the
  ///      number of requests received over the interval of time t_0+1 to
  ///      t_0+2 with a value of 2.
  case delta // = 1

  /// CUMULATIVE is an AggregationTemporality for a metric aggregator which
  /// reports changes since a fixed start time. This means that current values
  /// of a CUMULATIVE metric depend on all previous measurements since the
  /// start time. Because of this, the sender is required to retain this state
  /// in some form. If this state is lost or invalidated, the CUMULATIVE metric
  /// values MUST be reset and a new fixed start time following the last
  /// reported measurement time sent MUST be used.
  ///
  /// For example, consider a system measuring the number of requests that
  /// it receives and reports the sum of these requests every second as a
  /// CUMULATIVE metric:
  ///
  ///   1. The system starts receiving at time=t_0.
  ///   2. A request is received, the system measures 1 request.
  ///   3. A request is received, the system measures 1 request.
  ///   4. A request is received, the system measures 1 request.
  ///   5. The 1 second collection cycle ends. A metric is exported for the
  ///      number of requests received over the interval of time t_0 to
  ///      t_0+1 with a value of 3.
  ///   6. A request is received, the system measures 1 request.
  ///   7. A request is received, the system measures 1 request.
  ///   8. The 1 second collection cycle ends. A metric is exported for the
  ///      number of requests received over the interval of time t_0 to
  ///      t_0+2 with a value of 5.
  ///   9. The system experiences a fault and loses state.
  ///   10. The system recovers and resumes receiving at time=t_1.
  ///   11. A request is received, the system measures 1 request.
  ///   12. The 1 second collection cycle ends. A metric is exported for the
  ///      number of requests received over the interval of time t_1 to
  ///      t_0+1 with a value of 1.
  ///
  /// Note: Even though, when reporting changes since last report time, using 
  /// CUMULATIVE is valid, it is not recommended. This may cause problems for
  /// systems that do not use start_time to determine when the aggregation
  /// value was reset (e.g. Prometheus).
  case cumulative // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .delta
    case 2: self = .cumulative
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .delta: return 1
    case .cumulative: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Opentelemetry_Proto_Metrics_V1_AggregationTemporality: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Opentelemetry_Proto_Metrics_V1_AggregationTemporality] = [
    .unspecified,
    .delta,
    .cumulative,
  ]
}

#endif  // swift(>=4.2)

/// A collection of InstrumentationLibraryMetrics from a Resource.
public struct Opentelemetry_Proto_Metrics_V1_ResourceMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource for the metrics in this message.
  /// If this field is not set then no resource info is known.
  public var resource: Opentelemetry_Proto_Resource_V1_Resource {
    get {return _resource ?? Opentelemetry_Proto_Resource_V1_Resource()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  /// A list of metrics that originate from a resource.
  public var instrumentationLibraryMetrics: [Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _resource: Opentelemetry_Proto_Resource_V1_Resource? = nil
}

/// A collection of Metrics produced by an InstrumentationLibrary.
public struct Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instrumentation library information for the metrics in this message.
  /// Semantically when InstrumentationLibrary isn't set, it is equivalent with
  /// an empty instrumentation library name (unknown).
  public var instrumentationLibrary: Opentelemetry_Proto_Common_V1_InstrumentationLibrary {
    get {return _instrumentationLibrary ?? Opentelemetry_Proto_Common_V1_InstrumentationLibrary()}
    set {_instrumentationLibrary = newValue}
  }
  /// Returns true if `instrumentationLibrary` has been explicitly set.
  public var hasInstrumentationLibrary: Bool {return self._instrumentationLibrary != nil}
  /// Clears the value of `instrumentationLibrary`. Subsequent reads from it will return its default value.
  public mutating func clearInstrumentationLibrary() {self._instrumentationLibrary = nil}

  /// A list of metrics that originate from an instrumentation library.
  public var metrics: [Opentelemetry_Proto_Metrics_V1_Metric] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instrumentationLibrary: Opentelemetry_Proto_Common_V1_InstrumentationLibrary? = nil
}

/// Defines a Metric which has one or more timeseries.
///
/// The data model and relation between entities is shown in the
/// diagram below. Here, "DataPoint" is the term used to refer to any
/// one of the specific data point value types, and "points" is the term used
/// to refer to any one of the lists of points contained in the Metric.
///
/// - Metric is composed of a metadata and data.
/// - Metadata part contains a name, description, unit.
/// - Data is one of the possible types (Gauge, Sum, Histogram, etc.).
/// - DataPoint contains timestamps, labels, and one of the possible value type
///   fields.
///
///     Metric
///  +------------+
///  |name        |
///  |description |
///  |unit        |     +------------------------------------+
///  |data        |---> |Gauge, Sum, Histogram, Summary, ... |
///  +------------+     +------------------------------------+
///
///    Data [One of Gauge, Sum, Histogram, Summary, ...]
///  +-----------+
///  |...        |  // Metadata about the Data.
///  |points     |--+
///  +-----------+  |
///                 |      +---------------------------+
///                 |      |DataPoint 1                |
///                 v      |+------+------+   +------+ |
///              +-----+   ||label |label |...|label | |
///              |  1  |-->||value1|value2|...|valueN| |
///              +-----+   |+------+------+   +------+ |
///              |  .  |   |+-----+                    |
///              |  .  |   ||value|                    |
///              |  .  |   |+-----+                    |
///              |  .  |   +---------------------------+
///              |  .  |                   .
///              |  .  |                   .
///              |  .  |                   .
///              |  .  |   +---------------------------+
///              |  .  |   |DataPoint M                |
///              +-----+   |+------+------+   +------+ |
///              |  M  |-->||label |label |...|label | |
///              +-----+   ||value1|value2|...|valueN| |
///                        |+------+------+   +------+ |
///                        |+-----+                    |
///                        ||value|                    |
///                        |+-----+                    |
///                        +---------------------------+
///
/// All DataPoint types have three common fields:
/// - Labels zero or more key-value pairs associated with the data point.
/// - StartTimeUnixNano MUST be set to the start of the interval when the data's
///   type includes an AggregationTemporality. This field is not set otherwise.
/// - TimeUnixNano MUST be set to:
///   - the moment when an aggregation is reported (independent of the
///     aggregation temporality).
///   - the instantaneous time of the event.
public struct Opentelemetry_Proto_Metrics_V1_Metric {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name of the metric, including its DNS name prefix. It must be unique.
  public var name: String = String()

  /// description of the metric, which can be used in documentation.
  public var description_p: String = String()

  /// unit in which the metric value is reported. Follows the format
  /// described by http://unitsofmeasure.org/ucum.html.
  public var unit: String = String()

  /// Data determines the aggregation type (if any) of the metric, what is the
  /// reported value type for the data points, as well as the relatationship to
  /// the time interval over which they are reported.
  ///
  /// TODO: Update table after the decision on:
  /// https://github.com/open-telemetry/opentelemetry-specification/issues/731.
  /// By default, metrics recording using the OpenTelemetry API are exported as
  /// (the table does not include MeasurementValueType to avoid extra rows):
  ///
  ///   Instrument         Type
  ///   ----------------------------------------------
  ///   Counter            Sum(aggregation_temporality=delta;is_monotonic=true)
  ///   UpDownCounter      Sum(aggregation_temporality=delta;is_monotonic=false)
  ///   ValueRecorder      TBD
  ///   SumObserver        Sum(aggregation_temporality=cumulative;is_monotonic=true)
  ///   UpDownSumObserver  Sum(aggregation_temporality=cumulative;is_monotonic=false)
  ///   ValueObserver      Gauge()
  public var data: Opentelemetry_Proto_Metrics_V1_Metric.OneOf_Data? = nil

  public var intGauge: Opentelemetry_Proto_Metrics_V1_IntGauge {
    get {
      if case .intGauge(let v)? = data {return v}
      return Opentelemetry_Proto_Metrics_V1_IntGauge()
    }
    set {data = .intGauge(newValue)}
  }

  public var doubleGauge: Opentelemetry_Proto_Metrics_V1_DoubleGauge {
    get {
      if case .doubleGauge(let v)? = data {return v}
      return Opentelemetry_Proto_Metrics_V1_DoubleGauge()
    }
    set {data = .doubleGauge(newValue)}
  }

  public var intSum: Opentelemetry_Proto_Metrics_V1_IntSum {
    get {
      if case .intSum(let v)? = data {return v}
      return Opentelemetry_Proto_Metrics_V1_IntSum()
    }
    set {data = .intSum(newValue)}
  }

  public var doubleSum: Opentelemetry_Proto_Metrics_V1_DoubleSum {
    get {
      if case .doubleSum(let v)? = data {return v}
      return Opentelemetry_Proto_Metrics_V1_DoubleSum()
    }
    set {data = .doubleSum(newValue)}
  }

  public var intHistogram: Opentelemetry_Proto_Metrics_V1_IntHistogram {
    get {
      if case .intHistogram(let v)? = data {return v}
      return Opentelemetry_Proto_Metrics_V1_IntHistogram()
    }
    set {data = .intHistogram(newValue)}
  }

  public var doubleHistogram: Opentelemetry_Proto_Metrics_V1_DoubleHistogram {
    get {
      if case .doubleHistogram(let v)? = data {return v}
      return Opentelemetry_Proto_Metrics_V1_DoubleHistogram()
    }
    set {data = .doubleHistogram(newValue)}
  }

  public var doubleSummary: Opentelemetry_Proto_Metrics_V1_DoubleSummary {
    get {
      if case .doubleSummary(let v)? = data {return v}
      return Opentelemetry_Proto_Metrics_V1_DoubleSummary()
    }
    set {data = .doubleSummary(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Data determines the aggregation type (if any) of the metric, what is the
  /// reported value type for the data points, as well as the relatationship to
  /// the time interval over which they are reported.
  ///
  /// TODO: Update table after the decision on:
  /// https://github.com/open-telemetry/opentelemetry-specification/issues/731.
  /// By default, metrics recording using the OpenTelemetry API are exported as
  /// (the table does not include MeasurementValueType to avoid extra rows):
  ///
  ///   Instrument         Type
  ///   ----------------------------------------------
  ///   Counter            Sum(aggregation_temporality=delta;is_monotonic=true)
  ///   UpDownCounter      Sum(aggregation_temporality=delta;is_monotonic=false)
  ///   ValueRecorder      TBD
  ///   SumObserver        Sum(aggregation_temporality=cumulative;is_monotonic=true)
  ///   UpDownSumObserver  Sum(aggregation_temporality=cumulative;is_monotonic=false)
  ///   ValueObserver      Gauge()
  public enum OneOf_Data: Equatable {
    case intGauge(Opentelemetry_Proto_Metrics_V1_IntGauge)
    case doubleGauge(Opentelemetry_Proto_Metrics_V1_DoubleGauge)
    case intSum(Opentelemetry_Proto_Metrics_V1_IntSum)
    case doubleSum(Opentelemetry_Proto_Metrics_V1_DoubleSum)
    case intHistogram(Opentelemetry_Proto_Metrics_V1_IntHistogram)
    case doubleHistogram(Opentelemetry_Proto_Metrics_V1_DoubleHistogram)
    case doubleSummary(Opentelemetry_Proto_Metrics_V1_DoubleSummary)

  #if !swift(>=4.1)
    public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_Metric.OneOf_Data, rhs: Opentelemetry_Proto_Metrics_V1_Metric.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.intGauge, .intGauge): return {
        guard case .intGauge(let l) = lhs, case .intGauge(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.doubleGauge, .doubleGauge): return {
        guard case .doubleGauge(let l) = lhs, case .doubleGauge(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.intSum, .intSum): return {
        guard case .intSum(let l) = lhs, case .intSum(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.doubleSum, .doubleSum): return {
        guard case .doubleSum(let l) = lhs, case .doubleSum(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.intHistogram, .intHistogram): return {
        guard case .intHistogram(let l) = lhs, case .intHistogram(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.doubleHistogram, .doubleHistogram): return {
        guard case .doubleHistogram(let l) = lhs, case .doubleHistogram(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.doubleSummary, .doubleSummary): return {
        guard case .doubleSummary(let l) = lhs, case .doubleSummary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Gauge represents the type of a int scalar metric that always exports the
/// "current value" for every data point. It should be used for an "unknown"
/// aggregation.
/// 
/// A Gauge does not support different aggregation temporalities. Given the
/// aggregation is unknown, points cannot be combined using the same
/// aggregation, regardless of aggregation temporalities. Therefore,
/// AggregationTemporality is not included. Consequently, this also means
/// "StartTimeUnixNano" is ignored for all data points.
public struct Opentelemetry_Proto_Metrics_V1_IntGauge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dataPoints: [Opentelemetry_Proto_Metrics_V1_IntDataPoint] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Gauge represents the type of a double scalar metric that always exports the
/// "current value" for every data point. It should be used for an "unknown"
/// aggregation.
/// 
/// A Gauge does not support different aggregation temporalities. Given the
/// aggregation is unknown, points cannot be combined using the same
/// aggregation, regardless of aggregation temporalities. Therefore,
/// AggregationTemporality is not included. Consequently, this also means
/// "StartTimeUnixNano" is ignored for all data points.
public struct Opentelemetry_Proto_Metrics_V1_DoubleGauge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dataPoints: [Opentelemetry_Proto_Metrics_V1_DoubleDataPoint] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Sum represents the type of a numeric int scalar metric that is calculated as
/// a sum of all reported measurements over a time interval.
public struct Opentelemetry_Proto_Metrics_V1_IntSum {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dataPoints: [Opentelemetry_Proto_Metrics_V1_IntDataPoint] = []

  /// aggregation_temporality describes if the aggregator reports delta changes
  /// since last report time, or cumulative changes since a fixed start time.
  public var aggregationTemporality: Opentelemetry_Proto_Metrics_V1_AggregationTemporality = .unspecified

  /// If "true" means that the sum is monotonic.
  public var isMonotonic: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Sum represents the type of a numeric double scalar metric that is calculated
/// as a sum of all reported measurements over a time interval.
public struct Opentelemetry_Proto_Metrics_V1_DoubleSum {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dataPoints: [Opentelemetry_Proto_Metrics_V1_DoubleDataPoint] = []

  /// aggregation_temporality describes if the aggregator reports delta changes
  /// since last report time, or cumulative changes since a fixed start time.
  public var aggregationTemporality: Opentelemetry_Proto_Metrics_V1_AggregationTemporality = .unspecified

  /// If "true" means that the sum is monotonic.
  public var isMonotonic: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents the type of a metric that is calculated by aggregating as a
/// Histogram of all reported int measurements over a time interval.
public struct Opentelemetry_Proto_Metrics_V1_IntHistogram {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dataPoints: [Opentelemetry_Proto_Metrics_V1_IntHistogramDataPoint] = []

  /// aggregation_temporality describes if the aggregator reports delta changes
  /// since last report time, or cumulative changes since a fixed start time.
  public var aggregationTemporality: Opentelemetry_Proto_Metrics_V1_AggregationTemporality = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents the type of a metric that is calculated by aggregating as a
/// Histogram of all reported double measurements over a time interval.
public struct Opentelemetry_Proto_Metrics_V1_DoubleHistogram {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dataPoints: [Opentelemetry_Proto_Metrics_V1_DoubleHistogramDataPoint] = []

  /// aggregation_temporality describes if the aggregator reports delta changes
  /// since last report time, or cumulative changes since a fixed start time.
  public var aggregationTemporality: Opentelemetry_Proto_Metrics_V1_AggregationTemporality = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// DoubleSummary metric data are used to convey quantile summaries,
/// a Prometheus (see: https://prometheus.io/docs/concepts/metric_types/#summary)
/// and OpenMetrics (see: https://github.com/OpenObservability/OpenMetrics/blob/4dbf6075567ab43296eed941037c12951faafb92/protos/prometheus.proto#L45)
/// data type. These data points cannot always be merged in a meaningful way.
/// While they can be useful in some applications, histogram data points are
/// recommended for new applications.
public struct Opentelemetry_Proto_Metrics_V1_DoubleSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dataPoints: [Opentelemetry_Proto_Metrics_V1_DoubleSummaryDataPoint] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// IntDataPoint is a single data point in a timeseries that describes the
/// time-varying values of a int64 metric.
public struct Opentelemetry_Proto_Metrics_V1_IntDataPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of labels that uniquely identify this timeseries.
  public var labels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

  /// start_time_unix_nano is the last time when the aggregation value was reset
  /// to "zero". For some metric types this is ignored, see data types for more
  /// details.
  ///
  /// The aggregation value is over the time interval (start_time_unix_nano,
  /// time_unix_nano].
  /// 
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  ///
  /// Value of 0 indicates that the timestamp is unspecified. In that case the
  /// timestamp may be decided by the backend.
  public var startTimeUnixNano: UInt64 = 0

  /// time_unix_nano is the moment when this aggregation value was reported.
  /// 
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  public var timeUnixNano: UInt64 = 0

  /// value itself.
  public var value: Int64 = 0

  /// (Optional) List of exemplars collected from
  /// measurements that were used to form the data point
  public var exemplars: [Opentelemetry_Proto_Metrics_V1_IntExemplar] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// DoubleDataPoint is a single data point in a timeseries that describes the
/// time-varying value of a double metric.
public struct Opentelemetry_Proto_Metrics_V1_DoubleDataPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of labels that uniquely identify this timeseries.
  public var labels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

  /// start_time_unix_nano is the last time when the aggregation value was reset
  /// to "zero". For some metric types this is ignored, see data types for more
  /// details.
  ///
  /// The aggregation value is over the time interval (start_time_unix_nano,
  /// time_unix_nano].
  /// 
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  ///
  /// Value of 0 indicates that the timestamp is unspecified. In that case the
  /// timestamp may be decided by the backend.
  public var startTimeUnixNano: UInt64 = 0

  /// time_unix_nano is the moment when this aggregation value was reported.
  /// 
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  public var timeUnixNano: UInt64 = 0

  /// value itself.
  public var value: Double = 0

  /// (Optional) List of exemplars collected from
  /// measurements that were used to form the data point
  public var exemplars: [Opentelemetry_Proto_Metrics_V1_DoubleExemplar] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// IntHistogramDataPoint is a single data point in a timeseries that describes
/// the time-varying values of a Histogram of int values. A Histogram contains
/// summary statistics for a population of values, it may optionally contain
/// the distribution of those values across a set of buckets.
public struct Opentelemetry_Proto_Metrics_V1_IntHistogramDataPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of labels that uniquely identify this timeseries.
  public var labels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

  /// start_time_unix_nano is the last time when the aggregation value was reset
  /// to "zero". For some metric types this is ignored, see data types for more
  /// details.
  ///
  /// The aggregation value is over the time interval (start_time_unix_nano,
  /// time_unix_nano].
  /// 
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  ///
  /// Value of 0 indicates that the timestamp is unspecified. In that case the
  /// timestamp may be decided by the backend.
  public var startTimeUnixNano: UInt64 = 0

  /// time_unix_nano is the moment when this aggregation value was reported.
  /// 
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  public var timeUnixNano: UInt64 = 0

  /// count is the number of values in the population. Must be non-negative. This
  /// value must be equal to the sum of the "count" fields in buckets if a
  /// histogram is provided.
  public var count: UInt64 = 0

  /// sum of the values in the population. If count is zero then this field
  /// must be zero. This value must be equal to the sum of the "sum" fields in
  /// buckets if a histogram is provided.
  public var sum: Int64 = 0

  /// bucket_counts is an optional field contains the count values of histogram
  /// for each bucket.
  ///
  /// The sum of the bucket_counts must equal the value in the count field.
  ///
  /// The number of elements in bucket_counts array must be by one greater than
  /// the number of elements in explicit_bounds array.
  public var bucketCounts: [UInt64] = []

  /// explicit_bounds specifies buckets with explicitly defined bounds for values.
  /// The bucket boundaries are described by "bounds" field.
  ///
  /// This defines size(bounds) + 1 (= N) buckets. The boundaries for bucket
  /// at index i are:
  ///
  /// (-infinity, bounds[i]) for i == 0
  /// [bounds[i-1], bounds[i]) for 0 < i < N-1
  /// [bounds[i], +infinity) for i == N-1
  /// The values in bounds array must be strictly increasing.
  ///
  /// Note: only [a, b) intervals are currently supported for each bucket except the first one.
  /// If we decide to also support (a, b] intervals we should add support for these by defining
  /// a boolean value which decides what type of intervals to use.
  public var explicitBounds: [Double] = []

  /// (Optional) List of exemplars collected from
  /// measurements that were used to form the data point
  public var exemplars: [Opentelemetry_Proto_Metrics_V1_IntExemplar] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// HistogramDataPoint is a single data point in a timeseries that describes the
/// time-varying values of a Histogram of double values. A Histogram contains
/// summary statistics for a population of values, it may optionally contain the
/// distribution of those values across a set of buckets.
public struct Opentelemetry_Proto_Metrics_V1_DoubleHistogramDataPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of labels that uniquely identify this timeseries.
  public var labels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

  /// start_time_unix_nano is the last time when the aggregation value was reset
  /// to "zero". For some metric types this is ignored, see data types for more
  /// details.
  ///
  /// The aggregation value is over the time interval (start_time_unix_nano,
  /// time_unix_nano].
  /// 
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  ///
  /// Value of 0 indicates that the timestamp is unspecified. In that case the
  /// timestamp may be decided by the backend.
  public var startTimeUnixNano: UInt64 = 0

  /// time_unix_nano is the moment when this aggregation value was reported.
  /// 
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  public var timeUnixNano: UInt64 = 0

  /// count is the number of values in the population. Must be non-negative. This
  /// value must be equal to the sum of the "count" fields in buckets if a
  /// histogram is provided.
  public var count: UInt64 = 0

  /// sum of the values in the population. If count is zero then this field
  /// must be zero. This value must be equal to the sum of the "sum" fields in
  /// buckets if a histogram is provided.
  public var sum: Double = 0

  /// bucket_counts is an optional field contains the count values of histogram
  /// for each bucket.
  ///
  /// The sum of the bucket_counts must equal the value in the count field.
  ///
  /// The number of elements in bucket_counts array must be by one greater than
  /// the number of elements in explicit_bounds array.
  public var bucketCounts: [UInt64] = []

  /// explicit_bounds specifies buckets with explicitly defined bounds for values.
  /// The bucket boundaries are described by "bounds" field.
  ///
  /// This defines size(bounds) + 1 (= N) buckets. The boundaries for bucket
  /// at index i are:
  ///
  /// (-infinity, bounds[i]) for i == 0
  /// [bounds[i-1], bounds[i]) for 0 < i < N-1
  /// [bounds[i], +infinity) for i == N-1
  /// The values in bounds array must be strictly increasing.
  ///
  /// Note: only [a, b) intervals are currently supported for each bucket except the first one.
  /// If we decide to also support (a, b] intervals we should add support for these by defining
  /// a boolean value which decides what type of intervals to use.
  public var explicitBounds: [Double] = []

  /// (Optional) List of exemplars collected from
  /// measurements that were used to form the data point
  public var exemplars: [Opentelemetry_Proto_Metrics_V1_DoubleExemplar] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// DoubleSummaryDataPoint is a single data point in a timeseries that describes the
/// time-varying values of a Summary metric.
public struct Opentelemetry_Proto_Metrics_V1_DoubleSummaryDataPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of labels that uniquely identify this timeseries.
  public var labels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

  /// start_time_unix_nano is the last time when the aggregation value was reset
  /// to "zero". For some metric types this is ignored, see data types for more
  /// details.
  ///
  /// The aggregation value is over the time interval (start_time_unix_nano,
  /// time_unix_nano].
  ///
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  ///
  /// Value of 0 indicates that the timestamp is unspecified. In that case the
  /// timestamp may be decided by the backend.
  public var startTimeUnixNano: UInt64 = 0

  /// time_unix_nano is the moment when this aggregation value was reported.
  ///
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  public var timeUnixNano: UInt64 = 0

  /// count is the number of values in the population. Must be non-negative.
  public var count: UInt64 = 0

  /// sum of the values in the population. If count is zero then this field
  /// must be zero.
  public var sum: Double = 0

  /// (Optional) list of values at different quantiles of the distribution calculated
  /// from the current snapshot. The quantiles must be strictly increasing.
  public var quantileValues: [Opentelemetry_Proto_Metrics_V1_DoubleSummaryDataPoint.ValueAtQuantile] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Represents the value at a given quantile of a distribution.
  ///
  /// To record Min and Max values following conventions are used:
  /// - The 1.0 quantile is equivalent to the maximum value observed.
  /// - The 0.0 quantile is equivalent to the minimum value observed.
  ///
  /// See the following issue for more context:
  /// https://github.com/open-telemetry/opentelemetry-proto/issues/125
  public struct ValueAtQuantile {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The quantile of a distribution. Must be in the interval
    /// [0.0, 1.0].
    public var quantile: Double = 0

    /// The value at the given quantile of a distribution.
    public var value: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// A representation of an exemplar, which is a sample input int measurement.
/// Exemplars also hold information about the environment when the measurement
/// was recorded, for example the span and trace ID of the active span when the
/// exemplar was recorded.
public struct Opentelemetry_Proto_Metrics_V1_IntExemplar {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of labels that were filtered out by the aggregator, but recorded
  /// alongside the original measurement. Only labels that were filtered out
  /// by the aggregator should be included
  public var filteredLabels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

  /// time_unix_nano is the exact time when this exemplar was recorded
  ///
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  public var timeUnixNano: UInt64 = 0

  /// Numerical int value of the measurement that was recorded.
  public var value: Int64 = 0

  /// (Optional) Span ID of the exemplar trace.
  /// span_id may be missing if the measurement is not recorded inside a trace
  /// or if the trace is not sampled.
  public var spanID: Data = Data()

  /// (Optional) Trace ID of the exemplar trace.
  /// trace_id may be missing if the measurement is not recorded inside a trace
  /// or if the trace is not sampled.
  public var traceID: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A representation of an exemplar, which is a sample input double measurement.
/// Exemplars also hold information about the environment when the measurement
/// was recorded, for example the span and trace ID of the active span when the
/// exemplar was recorded.
public struct Opentelemetry_Proto_Metrics_V1_DoubleExemplar {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of labels that were filtered out by the aggregator, but recorded
  /// alongside the original measurement. Only labels that were filtered out
  /// by the aggregator should be included
  public var filteredLabels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

  /// time_unix_nano is the exact time when this exemplar was recorded
  ///
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  public var timeUnixNano: UInt64 = 0

  /// Numerical double value of the measurement that was recorded.
  public var value: Double = 0

  /// (Optional) Span ID of the exemplar trace.
  /// span_id may be missing if the measurement is not recorded inside a trace
  /// or if the trace is not sampled.
  public var spanID: Data = Data()

  /// (Optional) Trace ID of the exemplar trace.
  /// trace_id may be missing if the measurement is not recorded inside a trace
  /// or if the trace is not sampled.
  public var traceID: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "opentelemetry.proto.metrics.v1"

extension Opentelemetry_Proto_Metrics_V1_AggregationTemporality: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AGGREGATION_TEMPORALITY_UNSPECIFIED"),
    1: .same(proto: "AGGREGATION_TEMPORALITY_DELTA"),
    2: .same(proto: "AGGREGATION_TEMPORALITY_CUMULATIVE"),
  ]
}

extension Opentelemetry_Proto_Metrics_V1_ResourceMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resource"),
    2: .standard(proto: "instrumentation_library_metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instrumentationLibraryMetrics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.instrumentationLibraryMetrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instrumentationLibraryMetrics, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_ResourceMetrics, rhs: Opentelemetry_Proto_Metrics_V1_ResourceMetrics) -> Bool {
    if lhs._resource != rhs._resource {return false}
    if lhs.instrumentationLibraryMetrics != rhs.instrumentationLibraryMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InstrumentationLibraryMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instrumentation_library"),
    2: .same(proto: "metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instrumentationLibrary) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.metrics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._instrumentationLibrary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.metrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metrics, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics, rhs: Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics) -> Bool {
    if lhs._instrumentationLibrary != rhs._instrumentationLibrary {return false}
    if lhs.metrics != rhs.metrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_Metric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Metric"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .same(proto: "unit"),
    4: .standard(proto: "int_gauge"),
    5: .standard(proto: "double_gauge"),
    6: .standard(proto: "int_sum"),
    7: .standard(proto: "double_sum"),
    8: .standard(proto: "int_histogram"),
    9: .standard(proto: "double_histogram"),
    11: .standard(proto: "double_summary"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.unit) }()
      case 4: try {
        var v: Opentelemetry_Proto_Metrics_V1_IntGauge?
        if let current = self.data {
          try decoder.handleConflictingOneOf()
          if case .intGauge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.data = .intGauge(v)}
      }()
      case 5: try {
        var v: Opentelemetry_Proto_Metrics_V1_DoubleGauge?
        if let current = self.data {
          try decoder.handleConflictingOneOf()
          if case .doubleGauge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.data = .doubleGauge(v)}
      }()
      case 6: try {
        var v: Opentelemetry_Proto_Metrics_V1_IntSum?
        if let current = self.data {
          try decoder.handleConflictingOneOf()
          if case .intSum(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.data = .intSum(v)}
      }()
      case 7: try {
        var v: Opentelemetry_Proto_Metrics_V1_DoubleSum?
        if let current = self.data {
          try decoder.handleConflictingOneOf()
          if case .doubleSum(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.data = .doubleSum(v)}
      }()
      case 8: try {
        var v: Opentelemetry_Proto_Metrics_V1_IntHistogram?
        if let current = self.data {
          try decoder.handleConflictingOneOf()
          if case .intHistogram(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.data = .intHistogram(v)}
      }()
      case 9: try {
        var v: Opentelemetry_Proto_Metrics_V1_DoubleHistogram?
        if let current = self.data {
          try decoder.handleConflictingOneOf()
          if case .doubleHistogram(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.data = .doubleHistogram(v)}
      }()
      case 11: try {
        var v: Opentelemetry_Proto_Metrics_V1_DoubleSummary?
        if let current = self.data {
          try decoder.handleConflictingOneOf()
          if case .doubleSummary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.data = .doubleSummary(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.unit.isEmpty {
      try visitor.visitSingularStringField(value: self.unit, fieldNumber: 3)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.data {
    case .intGauge?: try {
      guard case .intGauge(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .doubleGauge?: try {
      guard case .doubleGauge(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .intSum?: try {
      guard case .intSum(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .doubleSum?: try {
      guard case .doubleSum(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .intHistogram?: try {
      guard case .intHistogram(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .doubleHistogram?: try {
      guard case .doubleHistogram(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .doubleSummary?: try {
      guard case .doubleSummary(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_Metric, rhs: Opentelemetry_Proto_Metrics_V1_Metric) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_IntGauge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntGauge"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_points"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dataPoints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_IntGauge, rhs: Opentelemetry_Proto_Metrics_V1_IntGauge) -> Bool {
    if lhs.dataPoints != rhs.dataPoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleGauge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DoubleGauge"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_points"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dataPoints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_DoubleGauge, rhs: Opentelemetry_Proto_Metrics_V1_DoubleGauge) -> Bool {
    if lhs.dataPoints != rhs.dataPoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_IntSum: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntSum"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_points"),
    2: .standard(proto: "aggregation_temporality"),
    3: .standard(proto: "is_monotonic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dataPoints) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.aggregationTemporality) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isMonotonic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
    }
    if self.aggregationTemporality != .unspecified {
      try visitor.visitSingularEnumField(value: self.aggregationTemporality, fieldNumber: 2)
    }
    if self.isMonotonic != false {
      try visitor.visitSingularBoolField(value: self.isMonotonic, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_IntSum, rhs: Opentelemetry_Proto_Metrics_V1_IntSum) -> Bool {
    if lhs.dataPoints != rhs.dataPoints {return false}
    if lhs.aggregationTemporality != rhs.aggregationTemporality {return false}
    if lhs.isMonotonic != rhs.isMonotonic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleSum: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DoubleSum"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_points"),
    2: .standard(proto: "aggregation_temporality"),
    3: .standard(proto: "is_monotonic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dataPoints) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.aggregationTemporality) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isMonotonic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
    }
    if self.aggregationTemporality != .unspecified {
      try visitor.visitSingularEnumField(value: self.aggregationTemporality, fieldNumber: 2)
    }
    if self.isMonotonic != false {
      try visitor.visitSingularBoolField(value: self.isMonotonic, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_DoubleSum, rhs: Opentelemetry_Proto_Metrics_V1_DoubleSum) -> Bool {
    if lhs.dataPoints != rhs.dataPoints {return false}
    if lhs.aggregationTemporality != rhs.aggregationTemporality {return false}
    if lhs.isMonotonic != rhs.isMonotonic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_IntHistogram: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntHistogram"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_points"),
    2: .standard(proto: "aggregation_temporality"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dataPoints) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.aggregationTemporality) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
    }
    if self.aggregationTemporality != .unspecified {
      try visitor.visitSingularEnumField(value: self.aggregationTemporality, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_IntHistogram, rhs: Opentelemetry_Proto_Metrics_V1_IntHistogram) -> Bool {
    if lhs.dataPoints != rhs.dataPoints {return false}
    if lhs.aggregationTemporality != rhs.aggregationTemporality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleHistogram: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DoubleHistogram"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_points"),
    2: .standard(proto: "aggregation_temporality"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dataPoints) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.aggregationTemporality) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
    }
    if self.aggregationTemporality != .unspecified {
      try visitor.visitSingularEnumField(value: self.aggregationTemporality, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_DoubleHistogram, rhs: Opentelemetry_Proto_Metrics_V1_DoubleHistogram) -> Bool {
    if lhs.dataPoints != rhs.dataPoints {return false}
    if lhs.aggregationTemporality != rhs.aggregationTemporality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DoubleSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_points"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dataPoints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_DoubleSummary, rhs: Opentelemetry_Proto_Metrics_V1_DoubleSummary) -> Bool {
    if lhs.dataPoints != rhs.dataPoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_IntDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntDataPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labels"),
    2: .standard(proto: "start_time_unix_nano"),
    3: .standard(proto: "time_unix_nano"),
    4: .same(proto: "value"),
    5: .same(proto: "exemplars"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.labels) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano) }()
      case 3: try { try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano) }()
      case 4: try { try decoder.decodeSingularSFixed64Field(value: &self.value) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.exemplars) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 1)
    }
    if self.startTimeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
    }
    if self.value != 0 {
      try visitor.visitSingularSFixed64Field(value: self.value, fieldNumber: 4)
    }
    if !self.exemplars.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exemplars, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_IntDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_IntDataPoint) -> Bool {
    if lhs.labels != rhs.labels {return false}
    if lhs.startTimeUnixNano != rhs.startTimeUnixNano {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.value != rhs.value {return false}
    if lhs.exemplars != rhs.exemplars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DoubleDataPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labels"),
    2: .standard(proto: "start_time_unix_nano"),
    3: .standard(proto: "time_unix_nano"),
    4: .same(proto: "value"),
    5: .same(proto: "exemplars"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.labels) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano) }()
      case 3: try { try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.exemplars) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 1)
    }
    if self.startTimeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
    }
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 4)
    }
    if !self.exemplars.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exemplars, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_DoubleDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_DoubleDataPoint) -> Bool {
    if lhs.labels != rhs.labels {return false}
    if lhs.startTimeUnixNano != rhs.startTimeUnixNano {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.value != rhs.value {return false}
    if lhs.exemplars != rhs.exemplars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_IntHistogramDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntHistogramDataPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labels"),
    2: .standard(proto: "start_time_unix_nano"),
    3: .standard(proto: "time_unix_nano"),
    4: .same(proto: "count"),
    5: .same(proto: "sum"),
    6: .standard(proto: "bucket_counts"),
    7: .standard(proto: "explicit_bounds"),
    8: .same(proto: "exemplars"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.labels) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano) }()
      case 3: try { try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano) }()
      case 4: try { try decoder.decodeSingularFixed64Field(value: &self.count) }()
      case 5: try { try decoder.decodeSingularSFixed64Field(value: &self.sum) }()
      case 6: try { try decoder.decodeRepeatedFixed64Field(value: &self.bucketCounts) }()
      case 7: try { try decoder.decodeRepeatedDoubleField(value: &self.explicitBounds) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.exemplars) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 1)
    }
    if self.startTimeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
    }
    if self.count != 0 {
      try visitor.visitSingularFixed64Field(value: self.count, fieldNumber: 4)
    }
    if self.sum != 0 {
      try visitor.visitSingularSFixed64Field(value: self.sum, fieldNumber: 5)
    }
    if !self.bucketCounts.isEmpty {
      try visitor.visitPackedFixed64Field(value: self.bucketCounts, fieldNumber: 6)
    }
    if !self.explicitBounds.isEmpty {
      try visitor.visitPackedDoubleField(value: self.explicitBounds, fieldNumber: 7)
    }
    if !self.exemplars.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exemplars, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_IntHistogramDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_IntHistogramDataPoint) -> Bool {
    if lhs.labels != rhs.labels {return false}
    if lhs.startTimeUnixNano != rhs.startTimeUnixNano {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.count != rhs.count {return false}
    if lhs.sum != rhs.sum {return false}
    if lhs.bucketCounts != rhs.bucketCounts {return false}
    if lhs.explicitBounds != rhs.explicitBounds {return false}
    if lhs.exemplars != rhs.exemplars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleHistogramDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DoubleHistogramDataPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labels"),
    2: .standard(proto: "start_time_unix_nano"),
    3: .standard(proto: "time_unix_nano"),
    4: .same(proto: "count"),
    5: .same(proto: "sum"),
    6: .standard(proto: "bucket_counts"),
    7: .standard(proto: "explicit_bounds"),
    8: .same(proto: "exemplars"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.labels) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano) }()
      case 3: try { try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano) }()
      case 4: try { try decoder.decodeSingularFixed64Field(value: &self.count) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.sum) }()
      case 6: try { try decoder.decodeRepeatedFixed64Field(value: &self.bucketCounts) }()
      case 7: try { try decoder.decodeRepeatedDoubleField(value: &self.explicitBounds) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.exemplars) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 1)
    }
    if self.startTimeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
    }
    if self.count != 0 {
      try visitor.visitSingularFixed64Field(value: self.count, fieldNumber: 4)
    }
    if self.sum != 0 {
      try visitor.visitSingularDoubleField(value: self.sum, fieldNumber: 5)
    }
    if !self.bucketCounts.isEmpty {
      try visitor.visitPackedFixed64Field(value: self.bucketCounts, fieldNumber: 6)
    }
    if !self.explicitBounds.isEmpty {
      try visitor.visitPackedDoubleField(value: self.explicitBounds, fieldNumber: 7)
    }
    if !self.exemplars.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exemplars, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_DoubleHistogramDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_DoubleHistogramDataPoint) -> Bool {
    if lhs.labels != rhs.labels {return false}
    if lhs.startTimeUnixNano != rhs.startTimeUnixNano {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.count != rhs.count {return false}
    if lhs.sum != rhs.sum {return false}
    if lhs.bucketCounts != rhs.bucketCounts {return false}
    if lhs.explicitBounds != rhs.explicitBounds {return false}
    if lhs.exemplars != rhs.exemplars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleSummaryDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DoubleSummaryDataPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labels"),
    2: .standard(proto: "start_time_unix_nano"),
    3: .standard(proto: "time_unix_nano"),
    4: .same(proto: "count"),
    5: .same(proto: "sum"),
    6: .standard(proto: "quantile_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.labels) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano) }()
      case 3: try { try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano) }()
      case 4: try { try decoder.decodeSingularFixed64Field(value: &self.count) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.sum) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.quantileValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 1)
    }
    if self.startTimeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
    }
    if self.count != 0 {
      try visitor.visitSingularFixed64Field(value: self.count, fieldNumber: 4)
    }
    if self.sum != 0 {
      try visitor.visitSingularDoubleField(value: self.sum, fieldNumber: 5)
    }
    if !self.quantileValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.quantileValues, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_DoubleSummaryDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_DoubleSummaryDataPoint) -> Bool {
    if lhs.labels != rhs.labels {return false}
    if lhs.startTimeUnixNano != rhs.startTimeUnixNano {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.count != rhs.count {return false}
    if lhs.sum != rhs.sum {return false}
    if lhs.quantileValues != rhs.quantileValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleSummaryDataPoint.ValueAtQuantile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opentelemetry_Proto_Metrics_V1_DoubleSummaryDataPoint.protoMessageName + ".ValueAtQuantile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "quantile"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.quantile) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.quantile != 0 {
      try visitor.visitSingularDoubleField(value: self.quantile, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_DoubleSummaryDataPoint.ValueAtQuantile, rhs: Opentelemetry_Proto_Metrics_V1_DoubleSummaryDataPoint.ValueAtQuantile) -> Bool {
    if lhs.quantile != rhs.quantile {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_IntExemplar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntExemplar"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "filtered_labels"),
    2: .standard(proto: "time_unix_nano"),
    3: .same(proto: "value"),
    4: .standard(proto: "span_id"),
    5: .standard(proto: "trace_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.filteredLabels) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano) }()
      case 3: try { try decoder.decodeSingularSFixed64Field(value: &self.value) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.spanID) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.traceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filteredLabels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filteredLabels, fieldNumber: 1)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 2)
    }
    if self.value != 0 {
      try visitor.visitSingularSFixed64Field(value: self.value, fieldNumber: 3)
    }
    if !self.spanID.isEmpty {
      try visitor.visitSingularBytesField(value: self.spanID, fieldNumber: 4)
    }
    if !self.traceID.isEmpty {
      try visitor.visitSingularBytesField(value: self.traceID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_IntExemplar, rhs: Opentelemetry_Proto_Metrics_V1_IntExemplar) -> Bool {
    if lhs.filteredLabels != rhs.filteredLabels {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.value != rhs.value {return false}
    if lhs.spanID != rhs.spanID {return false}
    if lhs.traceID != rhs.traceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleExemplar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DoubleExemplar"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "filtered_labels"),
    2: .standard(proto: "time_unix_nano"),
    3: .same(proto: "value"),
    4: .standard(proto: "span_id"),
    5: .standard(proto: "trace_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.filteredLabels) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.spanID) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.traceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filteredLabels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filteredLabels, fieldNumber: 1)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 2)
    }
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 3)
    }
    if !self.spanID.isEmpty {
      try visitor.visitSingularBytesField(value: self.spanID, fieldNumber: 4)
    }
    if !self.traceID.isEmpty {
      try visitor.visitSingularBytesField(value: self.traceID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_DoubleExemplar, rhs: Opentelemetry_Proto_Metrics_V1_DoubleExemplar) -> Bool {
    if lhs.filteredLabels != rhs.filteredLabels {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.value != rhs.value {return false}
    if lhs.spanID != rhs.spanID {return false}
    if lhs.traceID != rhs.traceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
