// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: opentelemetry/proto/metrics/v1/metrics.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A collection of InstrumentationLibraryMetrics from a Resource.
public struct Opentelemetry_Proto_Metrics_V1_ResourceMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource for the metrics in this message.
  /// If this field is not set then no resource info is known.
  public var resource: Opentelemetry_Proto_Resource_V1_Resource {
    get {return _storage._resource ?? Opentelemetry_Proto_Resource_V1_Resource()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// A list of metrics that originate from a resource.
  public var instrumentationLibraryMetrics: [Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics] {
    get {return _storage._instrumentationLibraryMetrics}
    set {_uniqueStorage()._instrumentationLibraryMetrics = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A collection of Metrics produced by an InstrumentationLibrary.
public struct Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instrumentation library information for the metrics in this message.
  /// If this field is not set then no library info is known.
  public var instrumentationLibrary: Opentelemetry_Proto_Common_V1_InstrumentationLibrary {
    get {return _storage._instrumentationLibrary ?? Opentelemetry_Proto_Common_V1_InstrumentationLibrary()}
    set {_uniqueStorage()._instrumentationLibrary = newValue}
  }
  /// Returns true if `instrumentationLibrary` has been explicitly set.
  public var hasInstrumentationLibrary: Bool {return _storage._instrumentationLibrary != nil}
  /// Clears the value of `instrumentationLibrary`. Subsequent reads from it will return its default value.
  public mutating func clearInstrumentationLibrary() {_uniqueStorage()._instrumentationLibrary = nil}

  /// A list of metrics that originate from an instrumentation library.
  public var metrics: [Opentelemetry_Proto_Metrics_V1_Metric] {
    get {return _storage._metrics}
    set {_uniqueStorage()._metrics = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Defines a Metric which has one or more timeseries.
///
/// The data model and relation between entities is shown in the diagram below.
///
/// - Metric is composed of a MetricDescriptor and a list of data points.
/// - MetricDescriptor contains a list of label keys (shown horizontally).
/// - Data is a list of DataPoints (shown vertically).
/// - DataPoint contains a list of label values and a value.
///
///     Metric
///  +----------+         +------------------------+
///  |descriptor|-------->| MetricDescriptor       |
///  |          |         |+-----+-----+   +-----+ |
///  |          |         ||label|label|...|label| |
///  |      data|--+      ||key1 |key2 |   |keyN | |
///  +----------+  |      |+-----+-----+   +-----+ |
///                |      +------------------------+
///                |
///                |      +---------------------------+
///                |      |DataPoint 1                |
///                v      |+------+------+   +------+ |
///             +-----+   ||label |label |...|label | |
///             |  1  |-->||value1|value2|...|valueN| |
///             +-----+   |+------+------+   +------+ |
///             |  .  |   |+-----+                    |
///             |  .  |   ||value|                    |
///             |  .  |   |+-----+                    |
///             |  .  |   +---------------------------+
///             |  .  |                   .
///             |  .  |                   .
///             |  .  |                   .
///             |  .  |   +---------------------------+
///             |  .  |   |DataPoint M                |
///             +-----+   |+------+------+   +------+ |
///             |  M  |-->||label |label |...|label | |
///             +-----+   ||value1|value2|...|valueN| |
///                       |+------+------+   +------+ |
///                       |+-----+                    |
///                       ||value|                    |
///                       |+-----+                    |
///                       +---------------------------+
///
///-----------------------------------------------------------------------
/// DataPoint is a value of specific type corresponding to a given moment in
/// time. Each DataPoint is timestamped.
///
/// DataPoint is strongly typed: each DataPoint type has a specific Protobuf message
/// depending on the value type of the metric and thus there are currently 4 DataPoint
/// messages, which correspond to the types of metric values.
public struct Opentelemetry_Proto_Metrics_V1_Metric {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// metric_descriptor describes the Metric.
  public var metricDescriptor: Opentelemetry_Proto_Metrics_V1_MetricDescriptor {
    get {return _storage._metricDescriptor ?? Opentelemetry_Proto_Metrics_V1_MetricDescriptor()}
    set {_uniqueStorage()._metricDescriptor = newValue}
  }
  /// Returns true if `metricDescriptor` has been explicitly set.
  public var hasMetricDescriptor: Bool {return _storage._metricDescriptor != nil}
  /// Clears the value of `metricDescriptor`. Subsequent reads from it will return its default value.
  public mutating func clearMetricDescriptor() {_uniqueStorage()._metricDescriptor = nil}

  /// Data is a list of one or more DataPoints for a single metric. Only one of the
  /// following fields is used for the data, depending on the type of the metric defined
  /// by MetricDescriptor.type field.
  public var int64DataPoints: [Opentelemetry_Proto_Metrics_V1_Int64DataPoint] {
    get {return _storage._int64DataPoints}
    set {_uniqueStorage()._int64DataPoints = newValue}
  }

  public var doubleDataPoints: [Opentelemetry_Proto_Metrics_V1_DoubleDataPoint] {
    get {return _storage._doubleDataPoints}
    set {_uniqueStorage()._doubleDataPoints = newValue}
  }

  public var histogramDataPoints: [Opentelemetry_Proto_Metrics_V1_HistogramDataPoint] {
    get {return _storage._histogramDataPoints}
    set {_uniqueStorage()._histogramDataPoints = newValue}
  }

  public var summaryDataPoints: [Opentelemetry_Proto_Metrics_V1_SummaryDataPoint] {
    get {return _storage._summaryDataPoints}
    set {_uniqueStorage()._summaryDataPoints = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Defines a metric type and its schema.
public struct Opentelemetry_Proto_Metrics_V1_MetricDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name of the metric, including its DNS name prefix. It must be unique.
  public var name: String = String()

  /// description of the metric, which can be used in documentation.
  public var description_p: String = String()

  /// unit in which the metric value is reported. Follows the format
  /// described by http://unitsofmeasure.org/ucum.html.
  public var unit: String = String()

  /// type is the type of values this metric has.
  public var type: Opentelemetry_Proto_Metrics_V1_MetricDescriptor.TypeEnum = .invalidType

  /// temporality is the Temporality of values this metric has.
  public var temporality: Opentelemetry_Proto_Metrics_V1_MetricDescriptor.Temporality = .invalidTemporality

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Type is the type of values a metric has.
  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// INVALID_TYPE is the default Type, it MUST not be used.
    case invalidType // = 0

    /// INT64 values are signed 64-bit integers.
    ///
    /// A Metric of this Type MUST store its values as Int64DataPoint.
    case int64 // = 1

    /// MONOTONIC_INT64 values are monotonically increasing signed 64-bit
    /// integers.
    ///
    /// A Metric of this Type MUST store its values as Int64DataPoint.
    case monotonicInt64 // = 2

    /// DOUBLE values are double-precision floating-point numbers.
    ///
    /// A Metric of this Type MUST store its values as DoubleDataPoint.
    case double // = 3

    /// MONOTONIC_DOUBLE values are monotonically increasing double-precision
    /// floating-point numbers.
    ///
    /// A Metric of this Type MUST store its values as DoubleDataPoint.
    case monotonicDouble // = 4

    /// Histogram measurement.
    /// Corresponding values are stored in HistogramDataPoint.
    case histogram // = 5

    /// Summary value. Some frameworks implemented Histograms as a summary of observations
    /// (usually things like request durations and response sizes). While it
    /// also provides a total count of observations and a sum of all observed
    /// values, it calculates configurable percentiles over a sliding time
    /// window.
    /// Corresponding values are stored in SummaryDataPoint.
    case summary // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .invalidType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .invalidType
      case 1: self = .int64
      case 2: self = .monotonicInt64
      case 3: self = .double
      case 4: self = .monotonicDouble
      case 5: self = .histogram
      case 6: self = .summary
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .invalidType: return 0
      case .int64: return 1
      case .monotonicInt64: return 2
      case .double: return 3
      case .monotonicDouble: return 4
      case .histogram: return 5
      case .summary: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Temporality is the temporal quality values of a metric have. It
  /// describes how those values relate to the time interval over which they
  /// are reported.
  public enum Temporality: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// INVALID_TEMPORALITY is the default Temporality, it MUST not be
    /// used.
    case invalidTemporality // = 0

    /// INSTANTANEOUS is a metric whose values are measured at a particular
    /// instant. The values are not aggregated over any time interval and are
    /// unique per timestamp. As such, these metrics are not expected to have
    /// an associated start time.
    case instantaneous // = 1

    /// DELTA is a metric whose values are the aggregation of measurements
    /// made over a time interval. Successive metrics contain aggregation of
    /// values from continuous and non-overlapping intervals.
    ///
    /// The values for a DELTA metric are based only on the time interval
    /// associated with one measurement cycle. There is no dependency on
    /// previous measurements like is the case for CUMULATIVE metrics.
    ///
    /// For example, consider a system measuring the number of requests that
    /// it receives and reports the sum of these requests every second as a
    /// DELTA metric:
    ///
    ///   1. The system starts receiving at time=t_0.
    ///   2. A request is received, the system measures 1 request.
    ///   3. A request is received, the system measures 1 request.
    ///   4. A request is received, the system measures 1 request.
    ///   5. The 1 second collection cycle ends. A metric is exported for the
    ///      number of requests received over the interval of time t_0 to
    ///      t_0+1 with a value of 3.
    ///   6. A request is received, the system measures 1 request.
    ///   7. A request is received, the system measures 1 request.
    ///   8. The 1 second collection cycle ends. A metric is exported for the
    ///      number of requests received over the interval of time t_0+1 to
    ///      t_0+2 with a value of 2.
    case delta // = 2

    /// CUMULATIVE is a metric whose values are the aggregation of
    /// successively made measurements from a fixed start time until the last
    /// reported measurement. This means that current values of a CUMULATIVE
    /// metric depend on all previous measurements since the start time.
    /// Because of this, the sender is required to retain this state in some
    /// form. If this state is lost or invalidated, the CUMULATIVE metric
    /// values MUST be reset and a new fixed start time following the last
    /// reported measurement time sent MUST be used.
    ///
    /// For example, consider a system measuring the number of requests that
    /// it receives and reports the sum of these requests every second as a
    /// CUMULATIVE metric:
    ///
    ///   1. The system starts receiving at time=t_0.
    ///   2. A request is received, the system measures 1 request.
    ///   3. A request is received, the system measures 1 request.
    ///   4. A request is received, the system measures 1 request.
    ///   5. The 1 second collection cycle ends. A metric is exported for the
    ///      number of requests received over the interval of time t_0 to
    ///      t_0+1 with a value of 3.
    ///   6. A request is received, the system measures 1 request.
    ///   7. A request is received, the system measures 1 request.
    ///   8. The 1 second collection cycle ends. A metric is exported for the
    ///      number of requests received over the interval of time t_0 to
    ///      t_0+2 with a value of 5.
    ///   9. The system experiences a fault and loses state.
    ///   10. The system recovers and resumes receiving at time=t_1.
    ///   11. A request is received, the system measures 1 request.
    ///   12. The 1 second collection cycle ends. A metric is exported for the
    ///      number of requests received over the interval of time t_1 to
    ///      t_0+1 with a value of 1.
    case cumulative // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .invalidTemporality
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .invalidTemporality
      case 1: self = .instantaneous
      case 2: self = .delta
      case 3: self = .cumulative
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .invalidTemporality: return 0
      case .instantaneous: return 1
      case .delta: return 2
      case .cumulative: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Opentelemetry_Proto_Metrics_V1_MetricDescriptor.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Opentelemetry_Proto_Metrics_V1_MetricDescriptor.TypeEnum] = [
    .invalidType,
    .int64,
    .monotonicInt64,
    .double,
    .monotonicDouble,
    .histogram,
    .summary,
  ]
}

extension Opentelemetry_Proto_Metrics_V1_MetricDescriptor.Temporality: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Opentelemetry_Proto_Metrics_V1_MetricDescriptor.Temporality] = [
    .invalidTemporality,
    .instantaneous,
    .delta,
    .cumulative,
  ]
}

#endif  // swift(>=4.2)

/// Int64DataPoint is a single data point in a timeseries that describes the time-varying
/// values of a int64 metric.
public struct Opentelemetry_Proto_Metrics_V1_Int64DataPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of labels that uniquely identify this timeseries.
  public var labels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

  /// start_time_unix_nano is the time when the cumulative value was reset to zero.
  /// This is used for Counter type only. For Gauge the value is not specified and
  /// defaults to 0.
  ///
  /// The cumulative value is over the time interval (start_time_unix_nano, time_unix_nano].
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
  ///
  /// Value of 0 indicates that the timestamp is unspecified. In that case the timestamp
  /// may be decided by the backend.
  public var startTimeUnixNano: UInt64 = 0

  /// time_unix_nano is the moment when this value was recorded.
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
  public var timeUnixNano: UInt64 = 0

  /// value itself.
  public var value: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// DoubleDataPoint is a single data point in a timeseries that describes the time-varying
/// value of a double metric.
public struct Opentelemetry_Proto_Metrics_V1_DoubleDataPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of labels that uniquely identify this timeseries.
  public var labels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

  /// start_time_unix_nano is the time when the cumulative value was reset to zero.
  /// This is used for Counter type only. For Gauge the value is not specified and
  /// defaults to 0.
  ///
  /// The cumulative value is over the time interval (start_time_unix_nano, time_unix_nano].
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
  ///
  /// Value of 0 indicates that the timestamp is unspecified. In that case the timestamp
  /// may be decided by the backend.
  public var startTimeUnixNano: UInt64 = 0

  /// time_unix_nano is the moment when this value was recorded.
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
  public var timeUnixNano: UInt64 = 0

  /// value itself.
  public var value: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// HistogramDataPoint is a single data point in a timeseries that describes the time-varying
/// values of a Histogram. A Histogram contains summary statistics for a population of values,
/// it may optionally contain the distribution of those values across a set of buckets.
public struct Opentelemetry_Proto_Metrics_V1_HistogramDataPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of labels that uniquely identify this timeseries.
  public var labels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

  /// start_time_unix_nano is the time when the cumulative value was reset to zero.
  ///
  /// The cumulative value is over the time interval (start_time_unix_nano, time_unix_nano].
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
  ///
  /// Value of 0 indicates that the timestamp is unspecified. In that case the timestamp
  /// may be decided by the backend.
  /// Note: this field is always unspecified and ignored if MetricDescriptor.type==GAUGE_HISTOGRAM.
  public var startTimeUnixNano: UInt64 = 0

  /// time_unix_nano is the moment when this value was recorded.
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
  public var timeUnixNano: UInt64 = 0

  /// count is the number of values in the population. Must be non-negative. This value
  /// must be equal to the sum of the "count" fields in buckets if a histogram is provided.
  public var count: UInt64 = 0

  /// sum of the values in the population. If count is zero then this field
  /// must be zero. This value must be equal to the sum of the "sum" fields in buckets if
  /// a histogram is provided.
  public var sum: Double = 0

  /// buckets is an optional field contains the values of histogram for each bucket.
  ///
  /// The sum of the values in the buckets "count" field must equal the value in the count field.
  ///
  /// The number of elements in buckets array must be by one greater than the
  /// number of elements in bucket_bounds array.
  ///
  /// Note: if HistogramDataPoint.bucket_options defines bucket bounds then this field
  /// must also be present and number of elements in this field must be equal to the
  /// number of buckets defined by bucket_options.
  public var buckets: [Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.Bucket] = []

  /// explicit_bounds specifies buckets with explicitly defined bounds for values.
  /// The bucket boundaries are described by "bounds" field.
  ///
  /// This defines size(bounds) + 1 (= N) buckets. The boundaries for bucket
  /// at index i are:
  ///
  /// [0, bounds[i]) for i == 0
  /// [bounds[i-1], bounds[i]) for 0 < i < N-1
  /// [bounds[i], +infinity) for i == N-1
  /// The values in bounds array must be strictly increasing and > 0.
  ///
  /// Note: only [a, b) intervals are currently supported for each bucket. If we decides
  /// to also support (a, b] intervals we should add support for these by defining a boolean
  /// value which decides what type of intervals to use.
  public var explicitBounds: [Double] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Bucket contains values for a bucket.
  public struct Bucket {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The number of values in each bucket of the histogram, as described by
    /// bucket_options.
    public var count: UInt64 {
      get {return _storage._count}
      set {_uniqueStorage()._count = newValue}
    }

    /// exemplar is an optional representative value of the bucket.
    public var exemplar: Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.Bucket.Exemplar {
      get {return _storage._exemplar ?? Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.Bucket.Exemplar()}
      set {_uniqueStorage()._exemplar = newValue}
    }
    /// Returns true if `exemplar` has been explicitly set.
    public var hasExemplar: Bool {return _storage._exemplar != nil}
    /// Clears the value of `exemplar`. Subsequent reads from it will return its default value.
    public mutating func clearExemplar() {_uniqueStorage()._exemplar = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Exemplars are example points that may be used to annotate aggregated
    /// Histogram values. They are metadata that gives information about a
    /// particular value added to a Histogram bucket.
    public struct Exemplar {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Value of the exemplar point. It determines which bucket the exemplar belongs to.
      /// If bucket_options define bounds for this bucket then this value must be within
      /// the defined bounds.
      public var value: Double = 0

      /// time_unix_nano is the moment when this exemplar was recorded.
      /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
      public var timeUnixNano: UInt64 = 0

      /// exemplar_attachments are contextual information about the example value.
      /// Keys in this list must be unique.
      public var attachments: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

/// SummaryDataPoint is a single data point in a timeseries that describes the time-varying
/// values of a Summary metric.
public struct Opentelemetry_Proto_Metrics_V1_SummaryDataPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of labels that uniquely identify this timeseries.
  public var labels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

  /// start_time_unix_nano is the time when the cumulative value was reset to zero.
  ///
  /// The cumulative value is over the time interval (start_time_unix_nano, time_unix_nano].
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
  ///
  /// Value of 0 indicates that the timestamp is unspecified. In that case the timestamp
  /// may be decided by the backend.
  public var startTimeUnixNano: UInt64 = 0

  /// time_unix_nano is the moment when this value was recorded.
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
  public var timeUnixNano: UInt64 = 0

  /// The total number of recorded values since start_time. Optional since
  /// some systems don't expose this.
  public var count: UInt64 = 0

  /// The total sum of recorded values since start_time. Optional since some
  /// systems don't expose this. If count is zero then this field must be zero.
  public var sum: Double = 0

  /// A list of values at different percentiles of the distribution calculated
  /// from the current snapshot. The percentiles must be strictly increasing.
  public var percentileValues: [Opentelemetry_Proto_Metrics_V1_SummaryDataPoint.ValueAtPercentile] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Represents the value at a given percentile of a distribution.
  ///
  /// To record Min and Max values following conventions are used:
  /// - The 100th percentile is equivalent to the maximum value observed.
  /// - The 0th percentile is equivalent to the minimum value observed.
  ///
  /// See the following issue for more context:
  /// https://github.com/open-telemetry/opentelemetry-proto/issues/125
  public struct ValueAtPercentile {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The percentile of a distribution. Must be in the interval
    /// [0.0, 100.0].
    public var percentile: Double = 0

    /// The value at the given percentile of a distribution.
    public var value: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "opentelemetry.proto.metrics.v1"

extension Opentelemetry_Proto_Metrics_V1_ResourceMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resource"),
    2: .standard(proto: "instrumentation_library_metrics"),
  ]

  fileprivate class _StorageClass {
    var _resource: Opentelemetry_Proto_Resource_V1_Resource? = nil
    var _instrumentationLibraryMetrics: [Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _resource = source._resource
      _instrumentationLibraryMetrics = source._instrumentationLibraryMetrics
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._resource)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._instrumentationLibraryMetrics)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._instrumentationLibraryMetrics.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._instrumentationLibraryMetrics, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_ResourceMetrics, rhs: Opentelemetry_Proto_Metrics_V1_ResourceMetrics) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._instrumentationLibraryMetrics != rhs_storage._instrumentationLibraryMetrics {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InstrumentationLibraryMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instrumentation_library"),
    2: .same(proto: "metrics"),
  ]

  fileprivate class _StorageClass {
    var _instrumentationLibrary: Opentelemetry_Proto_Common_V1_InstrumentationLibrary? = nil
    var _metrics: [Opentelemetry_Proto_Metrics_V1_Metric] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _instrumentationLibrary = source._instrumentationLibrary
      _metrics = source._metrics
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._instrumentationLibrary)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._metrics)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._instrumentationLibrary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._metrics.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._metrics, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics, rhs: Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._instrumentationLibrary != rhs_storage._instrumentationLibrary {return false}
        if _storage._metrics != rhs_storage._metrics {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_Metric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Metric"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_descriptor"),
    2: .standard(proto: "int64_data_points"),
    3: .standard(proto: "double_data_points"),
    4: .standard(proto: "histogram_data_points"),
    5: .standard(proto: "summary_data_points"),
  ]

  fileprivate class _StorageClass {
    var _metricDescriptor: Opentelemetry_Proto_Metrics_V1_MetricDescriptor? = nil
    var _int64DataPoints: [Opentelemetry_Proto_Metrics_V1_Int64DataPoint] = []
    var _doubleDataPoints: [Opentelemetry_Proto_Metrics_V1_DoubleDataPoint] = []
    var _histogramDataPoints: [Opentelemetry_Proto_Metrics_V1_HistogramDataPoint] = []
    var _summaryDataPoints: [Opentelemetry_Proto_Metrics_V1_SummaryDataPoint] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metricDescriptor = source._metricDescriptor
      _int64DataPoints = source._int64DataPoints
      _doubleDataPoints = source._doubleDataPoints
      _histogramDataPoints = source._histogramDataPoints
      _summaryDataPoints = source._summaryDataPoints
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metricDescriptor)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._int64DataPoints)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._doubleDataPoints)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._histogramDataPoints)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._summaryDataPoints)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metricDescriptor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._int64DataPoints.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._int64DataPoints, fieldNumber: 2)
      }
      if !_storage._doubleDataPoints.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._doubleDataPoints, fieldNumber: 3)
      }
      if !_storage._histogramDataPoints.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._histogramDataPoints, fieldNumber: 4)
      }
      if !_storage._summaryDataPoints.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._summaryDataPoints, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_Metric, rhs: Opentelemetry_Proto_Metrics_V1_Metric) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metricDescriptor != rhs_storage._metricDescriptor {return false}
        if _storage._int64DataPoints != rhs_storage._int64DataPoints {return false}
        if _storage._doubleDataPoints != rhs_storage._doubleDataPoints {return false}
        if _storage._histogramDataPoints != rhs_storage._histogramDataPoints {return false}
        if _storage._summaryDataPoints != rhs_storage._summaryDataPoints {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_MetricDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetricDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .same(proto: "unit"),
    4: .same(proto: "type"),
    5: .same(proto: "temporality"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.description_p)
      case 3: try decoder.decodeSingularStringField(value: &self.unit)
      case 4: try decoder.decodeSingularEnumField(value: &self.type)
      case 5: try decoder.decodeSingularEnumField(value: &self.temporality)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.unit.isEmpty {
      try visitor.visitSingularStringField(value: self.unit, fieldNumber: 3)
    }
    if self.type != .invalidType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    if self.temporality != .invalidTemporality {
      try visitor.visitSingularEnumField(value: self.temporality, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_MetricDescriptor, rhs: Opentelemetry_Proto_Metrics_V1_MetricDescriptor) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.type != rhs.type {return false}
    if lhs.temporality != rhs.temporality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_MetricDescriptor.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_TYPE"),
    1: .same(proto: "INT64"),
    2: .same(proto: "MONOTONIC_INT64"),
    3: .same(proto: "DOUBLE"),
    4: .same(proto: "MONOTONIC_DOUBLE"),
    5: .same(proto: "HISTOGRAM"),
    6: .same(proto: "SUMMARY"),
  ]
}

extension Opentelemetry_Proto_Metrics_V1_MetricDescriptor.Temporality: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_TEMPORALITY"),
    1: .same(proto: "INSTANTANEOUS"),
    2: .same(proto: "DELTA"),
    3: .same(proto: "CUMULATIVE"),
  ]
}

extension Opentelemetry_Proto_Metrics_V1_Int64DataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Int64DataPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labels"),
    2: .standard(proto: "start_time_unix_nano"),
    3: .standard(proto: "time_unix_nano"),
    4: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.labels)
      case 2: try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano)
      case 3: try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano)
      case 4: try decoder.decodeSingularInt64Field(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 1)
    }
    if self.startTimeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
    }
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_Int64DataPoint, rhs: Opentelemetry_Proto_Metrics_V1_Int64DataPoint) -> Bool {
    if lhs.labels != rhs.labels {return false}
    if lhs.startTimeUnixNano != rhs.startTimeUnixNano {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DoubleDataPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labels"),
    2: .standard(proto: "start_time_unix_nano"),
    3: .standard(proto: "time_unix_nano"),
    4: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.labels)
      case 2: try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano)
      case 3: try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano)
      case 4: try decoder.decodeSingularDoubleField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 1)
    }
    if self.startTimeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
    }
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_DoubleDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_DoubleDataPoint) -> Bool {
    if lhs.labels != rhs.labels {return false}
    if lhs.startTimeUnixNano != rhs.startTimeUnixNano {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_HistogramDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HistogramDataPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labels"),
    2: .standard(proto: "start_time_unix_nano"),
    3: .standard(proto: "time_unix_nano"),
    4: .same(proto: "count"),
    5: .same(proto: "sum"),
    6: .same(proto: "buckets"),
    7: .standard(proto: "explicit_bounds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.labels)
      case 2: try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano)
      case 3: try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.count)
      case 5: try decoder.decodeSingularDoubleField(value: &self.sum)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.buckets)
      case 7: try decoder.decodeRepeatedDoubleField(value: &self.explicitBounds)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 1)
    }
    if self.startTimeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt64Field(value: self.count, fieldNumber: 4)
    }
    if self.sum != 0 {
      try visitor.visitSingularDoubleField(value: self.sum, fieldNumber: 5)
    }
    if !self.buckets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buckets, fieldNumber: 6)
    }
    if !self.explicitBounds.isEmpty {
      try visitor.visitPackedDoubleField(value: self.explicitBounds, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_HistogramDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_HistogramDataPoint) -> Bool {
    if lhs.labels != rhs.labels {return false}
    if lhs.startTimeUnixNano != rhs.startTimeUnixNano {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.count != rhs.count {return false}
    if lhs.sum != rhs.sum {return false}
    if lhs.buckets != rhs.buckets {return false}
    if lhs.explicitBounds != rhs.explicitBounds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.Bucket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.protoMessageName + ".Bucket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "exemplar"),
  ]

  fileprivate class _StorageClass {
    var _count: UInt64 = 0
    var _exemplar: Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.Bucket.Exemplar? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _count = source._count
      _exemplar = source._exemplar
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._count)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._exemplar)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._count != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._count, fieldNumber: 1)
      }
      if let v = _storage._exemplar {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.Bucket, rhs: Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.Bucket) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._count != rhs_storage._count {return false}
        if _storage._exemplar != rhs_storage._exemplar {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.Bucket.Exemplar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.Bucket.protoMessageName + ".Exemplar"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "time_unix_nano"),
    3: .same(proto: "attachments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.value)
      case 2: try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.attachments)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 1)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 2)
    }
    if !self.attachments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachments, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.Bucket.Exemplar, rhs: Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.Bucket.Exemplar) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.attachments != rhs.attachments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_SummaryDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SummaryDataPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labels"),
    2: .standard(proto: "start_time_unix_nano"),
    3: .standard(proto: "time_unix_nano"),
    4: .same(proto: "count"),
    5: .same(proto: "sum"),
    6: .standard(proto: "percentile_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.labels)
      case 2: try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano)
      case 3: try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.count)
      case 5: try decoder.decodeSingularDoubleField(value: &self.sum)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.percentileValues)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 1)
    }
    if self.startTimeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt64Field(value: self.count, fieldNumber: 4)
    }
    if self.sum != 0 {
      try visitor.visitSingularDoubleField(value: self.sum, fieldNumber: 5)
    }
    if !self.percentileValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.percentileValues, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_SummaryDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_SummaryDataPoint) -> Bool {
    if lhs.labels != rhs.labels {return false}
    if lhs.startTimeUnixNano != rhs.startTimeUnixNano {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.count != rhs.count {return false}
    if lhs.sum != rhs.sum {return false}
    if lhs.percentileValues != rhs.percentileValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_SummaryDataPoint.ValueAtPercentile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opentelemetry_Proto_Metrics_V1_SummaryDataPoint.protoMessageName + ".ValueAtPercentile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "percentile"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.percentile)
      case 2: try decoder.decodeSingularDoubleField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.percentile != 0 {
      try visitor.visitSingularDoubleField(value: self.percentile, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_SummaryDataPoint.ValueAtPercentile, rhs: Opentelemetry_Proto_Metrics_V1_SummaryDataPoint.ValueAtPercentile) -> Bool {
    if lhs.percentile != rhs.percentile {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
