// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: opentelemetry/proto/profiles/v1development/profiles.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2023, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// This file includes work covered by the following copyright and permission notices:
//
// Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Specifies the method of aggregating metric values, either DELTA (change since last report)
/// or CUMULATIVE (total since a fixed start time).
public enum Opentelemetry_Proto_Profiles_V1development_AggregationTemporality: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// UNSPECIFIED is the default AggregationTemporality, it MUST not be used. 
  case unspecified // = 0

  ///* DELTA is an AggregationTemporality for a profiler which reports
  ///changes since last report time. Successive metrics contain aggregation of
  ///values from continuous and non-overlapping intervals.
  ///
  ///The values for a DELTA metric are based only on the time interval
  ///associated with one measurement cycle. There is no dependency on
  ///previous measurements like is the case for CUMULATIVE metrics.
  ///
  ///For example, consider a system measuring the number of requests that
  ///it receives and reports the sum of these requests every second as a
  ///DELTA metric:
  ///
  ///1. The system starts receiving at time=t_0.
  ///2. A request is received, the system measures 1 request.
  ///3. A request is received, the system measures 1 request.
  ///4. A request is received, the system measures 1 request.
  ///5. The 1 second collection cycle ends. A metric is exported for the
  ///number of requests received over the interval of time t_0 to
  ///t_0+1 with a value of 3.
  ///6. A request is received, the system measures 1 request.
  ///7. A request is received, the system measures 1 request.
  ///8. The 1 second collection cycle ends. A metric is exported for the
  ///number of requests received over the interval of time t_0+1 to
  ///t_0+2 with a value of 2. 
  case delta // = 1

  ///* CUMULATIVE is an AggregationTemporality for a profiler which
  ///reports changes since a fixed start time. This means that current values
  ///of a CUMULATIVE metric depend on all previous measurements since the
  ///start time. Because of this, the sender is required to retain this state
  ///in some form. If this state is lost or invalidated, the CUMULATIVE metric
  ///values MUST be reset and a new fixed start time following the last
  ///reported measurement time sent MUST be used.
  ///
  ///For example, consider a system measuring the number of requests that
  ///it receives and reports the sum of these requests every second as a
  ///CUMULATIVE metric:
  ///
  ///1. The system starts receiving at time=t_0.
  ///2. A request is received, the system measures 1 request.
  ///3. A request is received, the system measures 1 request.
  ///4. A request is received, the system measures 1 request.
  ///5. The 1 second collection cycle ends. A metric is exported for the
  ///number of requests received over the interval of time t_0 to
  ///t_0+1 with a value of 3.
  ///6. A request is received, the system measures 1 request.
  ///7. A request is received, the system measures 1 request.
  ///8. The 1 second collection cycle ends. A metric is exported for the
  ///number of requests received over the interval of time t_0 to
  ///t_0+2 with a value of 5.
  ///9. The system experiences a fault and loses state.
  ///10. The system recovers and resumes receiving at time=t_1.
  ///11. A request is received, the system measures 1 request.
  ///12. The 1 second collection cycle ends. A metric is exported for the
  ///number of requests received over the interval of time t_1 to
  ///t_1+1 with a value of 1.
  ///
  ///Note: Even though, when reporting changes since last report time, using
  ///CUMULATIVE is valid, it is not recommended. 
  case cumulative // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .delta
    case 2: self = .cumulative
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .delta: return 1
    case .cumulative: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Opentelemetry_Proto_Profiles_V1development_AggregationTemporality] = [
    .unspecified,
    .delta,
    .cumulative,
  ]

}

/// ProfilesData represents the profiles data that can be stored in persistent storage,
/// OR can be embedded by other protocols that transfer OTLP profiles data but do not
/// implement the OTLP protocol.
///
/// The main difference between this message and collector protocol is that
/// in this message there will not be any "control" or "metadata" specific to
/// OTLP protocol.
///
/// When new fields are added into this message, the OTLP request MUST be updated
/// as well.
public struct Opentelemetry_Proto_Profiles_V1development_ProfilesData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An array of ResourceProfiles.
  /// For data coming from a single resource this array will typically contain
  /// one element. Intermediary nodes that receive data from multiple origins
  /// typically batch the data before forwarding further and in that case this
  /// array will contain multiple elements.
  public var resourceProfiles: [Opentelemetry_Proto_Profiles_V1development_ResourceProfiles] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A collection of ScopeProfiles from a Resource.
public struct Opentelemetry_Proto_Profiles_V1development_ResourceProfiles: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource for the profiles in this message.
  /// If this field is not set then no resource info is known.
  public var resource: Opentelemetry_Proto_Resource_V1_Resource {
    get {return _resource ?? Opentelemetry_Proto_Resource_V1_Resource()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  /// A list of ScopeProfiles that originate from a resource.
  public var scopeProfiles: [Opentelemetry_Proto_Profiles_V1development_ScopeProfiles] = []

  /// The Schema URL, if known. This is the identifier of the Schema that the resource data
  /// is recorded in. Notably, the last part of the URL path is the version number of the
  /// schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
  /// https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
  /// This schema_url applies to the data in the "resource" field. It does not apply
  /// to the data in the "scope_profiles" field which have their own schema_url field.
  public var schemaURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _resource: Opentelemetry_Proto_Resource_V1_Resource? = nil
}

/// A collection of Profiles produced by an InstrumentationScope.
public struct Opentelemetry_Proto_Profiles_V1development_ScopeProfiles: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instrumentation scope information for the profiles in this message.
  /// Semantically when InstrumentationScope isn't set, it is equivalent with
  /// an empty instrumentation scope name (unknown).
  public var scope: Opentelemetry_Proto_Common_V1_InstrumentationScope {
    get {return _scope ?? Opentelemetry_Proto_Common_V1_InstrumentationScope()}
    set {_scope = newValue}
  }
  /// Returns true if `scope` has been explicitly set.
  public var hasScope: Bool {return self._scope != nil}
  /// Clears the value of `scope`. Subsequent reads from it will return its default value.
  public mutating func clearScope() {self._scope = nil}

  /// A list of Profiles that originate from an instrumentation scope.
  public var profiles: [Opentelemetry_Proto_Profiles_V1development_Profile] = []

  /// The Schema URL, if known. This is the identifier of the Schema that the profile data
  /// is recorded in. Notably, the last part of the URL path is the version number of the
  /// schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
  /// https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
  /// This schema_url applies to all profiles in the "profiles" field.
  public var schemaURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _scope: Opentelemetry_Proto_Common_V1_InstrumentationScope? = nil
}

/// Represents a complete profile, including sample types, samples,
/// mappings to binaries, locations, functions, string table, and additional metadata.
/// It modifies and annotates pprof Profile with OpenTelemetry specific fields.
///
/// Note that whilst fields in this message retain the name and field id from pprof in most cases
/// for ease of understanding data migration, it is not intended that pprof:Profile and
/// OpenTelemetry:Profile encoding be wire compatible.
public struct Opentelemetry_Proto_Profiles_V1development_Profile: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A description of the samples associated with each Sample.value.
  /// For a cpu profile this might be:
  ///   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
  /// For a heap profile, this might be:
  ///   [["allocations","count"], ["space","bytes"]],
  /// If one of the values represents the number of events represented
  /// by the sample, by convention it should be at index 0 and use
  /// sample_type.unit == "count".
  public var sampleType: [Opentelemetry_Proto_Profiles_V1development_ValueType] {
    get {return _storage._sampleType}
    set {_uniqueStorage()._sampleType = newValue}
  }

  /// The set of samples recorded in this profile.
  public var sample: [Opentelemetry_Proto_Profiles_V1development_Sample] {
    get {return _storage._sample}
    set {_uniqueStorage()._sample = newValue}
  }

  /// Mapping from address ranges to the image/binary/library mapped
  /// into that address range.  mapping[0] will be the main binary.
  /// If multiple binaries contribute to the Profile and no main
  /// binary can be identified, mapping[0] has no special meaning.
  public var mappingTable: [Opentelemetry_Proto_Profiles_V1development_Mapping] {
    get {return _storage._mappingTable}
    set {_uniqueStorage()._mappingTable = newValue}
  }

  /// Locations referenced by samples via location_indices.
  public var locationTable: [Opentelemetry_Proto_Profiles_V1development_Location] {
    get {return _storage._locationTable}
    set {_uniqueStorage()._locationTable = newValue}
  }

  /// Array of locations referenced by samples.
  public var locationIndices: [Int32] {
    get {return _storage._locationIndices}
    set {_uniqueStorage()._locationIndices = newValue}
  }

  /// Functions referenced by locations.
  public var functionTable: [Opentelemetry_Proto_Profiles_V1development_Function] {
    get {return _storage._functionTable}
    set {_uniqueStorage()._functionTable = newValue}
  }

  /// Lookup table for attributes.
  public var attributeTable: [Opentelemetry_Proto_Common_V1_KeyValue] {
    get {return _storage._attributeTable}
    set {_uniqueStorage()._attributeTable = newValue}
  }

  /// Represents a mapping between Attribute Keys and Units.
  public var attributeUnits: [Opentelemetry_Proto_Profiles_V1development_AttributeUnit] {
    get {return _storage._attributeUnits}
    set {_uniqueStorage()._attributeUnits = newValue}
  }

  /// Lookup table for links.
  public var linkTable: [Opentelemetry_Proto_Profiles_V1development_Link] {
    get {return _storage._linkTable}
    set {_uniqueStorage()._linkTable = newValue}
  }

  /// A common table for strings referenced by various messages.
  /// string_table[0] must always be "".
  public var stringTable: [String] {
    get {return _storage._stringTable}
    set {_uniqueStorage()._stringTable = newValue}
  }

  /// Time of collection (UTC) represented as nanoseconds past the epoch.
  public var timeNanos: Int64 {
    get {return _storage._timeNanos}
    set {_uniqueStorage()._timeNanos = newValue}
  }

  /// Duration of the profile, if a duration makes sense.
  public var durationNanos: Int64 {
    get {return _storage._durationNanos}
    set {_uniqueStorage()._durationNanos = newValue}
  }

  /// The kind of events between sampled occurrences.
  /// e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
  public var periodType: Opentelemetry_Proto_Profiles_V1development_ValueType {
    get {return _storage._periodType ?? Opentelemetry_Proto_Profiles_V1development_ValueType()}
    set {_uniqueStorage()._periodType = newValue}
  }
  /// Returns true if `periodType` has been explicitly set.
  public var hasPeriodType: Bool {return _storage._periodType != nil}
  /// Clears the value of `periodType`. Subsequent reads from it will return its default value.
  public mutating func clearPeriodType() {_uniqueStorage()._periodType = nil}

  /// The number of events between sampled occurrences.
  public var period: Int64 {
    get {return _storage._period}
    set {_uniqueStorage()._period = newValue}
  }

  /// Free-form text associated with the profile. The text is displayed as is
  /// to the user by the tools that read profiles (e.g. by pprof). This field
  /// should not be used to store any machine-readable information, it is only
  /// for human-friendly content. The profile must stay functional if this field
  /// is cleaned.
  public var commentStrindices: [Int32] {
    get {return _storage._commentStrindices}
    set {_uniqueStorage()._commentStrindices = newValue}
  }

  /// Index into the string table of the type of the preferred sample
  /// value. If unset, clients should default to the last sample value.
  public var defaultSampleTypeStrindex: Int32 {
    get {return _storage._defaultSampleTypeStrindex}
    set {_uniqueStorage()._defaultSampleTypeStrindex = newValue}
  }

  /// A globally unique identifier for a profile. The ID is a 16-byte array. An ID with
  /// all zeroes is considered invalid.
  ///
  /// This field is required.
  public var profileID: Data {
    get {return _storage._profileID}
    set {_uniqueStorage()._profileID = newValue}
  }

  /// dropped_attributes_count is the number of attributes that were discarded. Attributes
  /// can be discarded because their keys are too long or because there are too many
  /// attributes. If this value is 0, then no attributes were dropped.
  public var droppedAttributesCount: UInt32 {
    get {return _storage._droppedAttributesCount}
    set {_uniqueStorage()._droppedAttributesCount = newValue}
  }

  /// Specifies format of the original payload. Common values are defined in semantic conventions. [required if original_payload is present]
  public var originalPayloadFormat: String {
    get {return _storage._originalPayloadFormat}
    set {_uniqueStorage()._originalPayloadFormat = newValue}
  }

  /// Original payload can be stored in this field. This can be useful for users who want to get the original payload.
  /// Formats such as JFR are highly extensible and can contain more information than what is defined in this spec.
  /// Inclusion of original payload should be configurable by the user. Default behavior should be to not include the original payload.
  /// If the original payload is in pprof format, it SHOULD not be included in this field.
  /// The field is optional, however if it is present then equivalent converted data should be populated in other fields
  /// of this message as far as is practicable.
  public var originalPayload: Data {
    get {return _storage._originalPayload}
    set {_uniqueStorage()._originalPayload = newValue}
  }

  /// References to attributes in attribute_table. [optional]
  /// It is a collection of key/value pairs. Note, global attributes
  /// like server name can be set using the resource API. Examples of attributes:
  ///
  ///     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
  ///     "/http/server_latency": 300
  ///     "abc.com/myattribute": true
  ///     "abc.com/score": 10.239
  ///
  /// The OpenTelemetry API specification further restricts the allowed value types:
  /// https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/README.md#attribute
  /// Attribute keys MUST be unique (it is not allowed to have more than one
  /// attribute with the same key).
  public var attributeIndices: [Int32] {
    get {return _storage._attributeIndices}
    set {_uniqueStorage()._attributeIndices = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents a mapping between Attribute Keys and Units.
public struct Opentelemetry_Proto_Profiles_V1development_AttributeUnit: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Index into string table.
  public var attributeKeyStrindex: Int32 = 0

  /// Index into string table.
  public var unitStrindex: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A pointer from a profile Sample to a trace Span.
/// Connects a profile sample to a trace span, identified by unique trace and span IDs.
public struct Opentelemetry_Proto_Profiles_V1development_Link: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier of a trace that this linked span is part of. The ID is a
  /// 16-byte array.
  public var traceID: Data = Data()

  /// A unique identifier for the linked span. The ID is an 8-byte array.
  public var spanID: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ValueType describes the type and units of a value, with an optional aggregation temporality.
public struct Opentelemetry_Proto_Profiles_V1development_ValueType: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Index into string table.
  public var typeStrindex: Int32 = 0

  /// Index into string table.
  public var unitStrindex: Int32 = 0

  public var aggregationTemporality: Opentelemetry_Proto_Profiles_V1development_AggregationTemporality = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Each Sample records values encountered in some program
/// context. The program context is typically a stack trace, perhaps
/// augmented with auxiliary information like the thread-id, some
/// indicator of a higher level request being handled etc.
public struct Opentelemetry_Proto_Profiles_V1development_Sample: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// locations_start_index along with locations_length refers to to a slice of locations in Profile.location_indices.
  public var locationsStartIndex: Int32 = 0

  /// locations_length along with locations_start_index refers to a slice of locations in Profile.location_indices.
  /// Supersedes location_index.
  public var locationsLength: Int32 = 0

  /// The type and unit of each value is defined by the corresponding
  /// entry in Profile.sample_type. All samples must have the same
  /// number of values, the same as the length of Profile.sample_type.
  /// When aggregating multiple samples into a single sample, the
  /// result has a list of values that is the element-wise sum of the
  /// lists of the originals.
  public var value: [Int64] = []

  /// References to attributes in Profile.attribute_table. [optional]
  public var attributeIndices: [Int32] = []

  /// Reference to link in Profile.link_table. [optional]
  public var linkIndex: Int32 {
    get {return _linkIndex ?? 0}
    set {_linkIndex = newValue}
  }
  /// Returns true if `linkIndex` has been explicitly set.
  public var hasLinkIndex: Bool {return self._linkIndex != nil}
  /// Clears the value of `linkIndex`. Subsequent reads from it will return its default value.
  public mutating func clearLinkIndex() {self._linkIndex = nil}

  /// Timestamps associated with Sample represented in nanoseconds. These timestamps are expected
  /// to fall within the Profile's time range. [optional]
  public var timestampsUnixNano: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _linkIndex: Int32? = nil
}

/// Describes the mapping of a binary in memory, including its address range,
/// file offset, and metadata like build ID
public struct Opentelemetry_Proto_Profiles_V1development_Mapping: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Address at which the binary (or DLL) is loaded into memory.
  public var memoryStart: UInt64 = 0

  /// The limit of the address range occupied by this mapping.
  public var memoryLimit: UInt64 = 0

  /// Offset in the binary that corresponds to the first mapped address.
  public var fileOffset: UInt64 = 0

  /// The object this entry is loaded from.  This can be a filename on
  /// disk for the main binary and shared libraries, or virtual
  /// abstractions like "[vdso]".
  public var filenameStrindex: Int32 = 0

  /// References to attributes in Profile.attribute_table. [optional]
  public var attributeIndices: [Int32] = []

  /// The following fields indicate the resolution of symbolic info.
  public var hasFunctions_p: Bool = false

  public var hasFilenames_p: Bool = false

  public var hasLineNumbers_p: Bool = false

  public var hasInlineFrames_p: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes function and line table debug information.
public struct Opentelemetry_Proto_Profiles_V1development_Location: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Reference to mapping in Profile.mapping_table.
  /// It can be unset if the mapping is unknown or not applicable for
  /// this profile type.
  public var mappingIndex: Int32 {
    get {return _mappingIndex ?? 0}
    set {_mappingIndex = newValue}
  }
  /// Returns true if `mappingIndex` has been explicitly set.
  public var hasMappingIndex: Bool {return self._mappingIndex != nil}
  /// Clears the value of `mappingIndex`. Subsequent reads from it will return its default value.
  public mutating func clearMappingIndex() {self._mappingIndex = nil}

  /// The instruction address for this location, if available.  It
  /// should be within [Mapping.memory_start...Mapping.memory_limit]
  /// for the corresponding mapping. A non-leaf address may be in the
  /// middle of a call instruction. It is up to display tools to find
  /// the beginning of the instruction if necessary.
  public var address: UInt64 = 0

  /// Multiple line indicates this location has inlined functions,
  /// where the last entry represents the caller into which the
  /// preceding entries were inlined.
  ///
  /// E.g., if memcpy() is inlined into printf:
  ///    line[0].function_name == "memcpy"
  ///    line[1].function_name == "printf"
  public var line: [Opentelemetry_Proto_Profiles_V1development_Line] = []

  /// Provides an indication that multiple symbols map to this location's
  /// address, for example due to identical code folding by the linker. In that
  /// case the line information above represents one of the multiple
  /// symbols. This field must be recomputed when the symbolization state of the
  /// profile changes.
  public var isFolded: Bool = false

  /// References to attributes in Profile.attribute_table. [optional]
  public var attributeIndices: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _mappingIndex: Int32? = nil
}

/// Details a specific line in a source code, linked to a function.
public struct Opentelemetry_Proto_Profiles_V1development_Line: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Reference to function in Profile.function_table.
  public var functionIndex: Int32 = 0

  /// Line number in source code.
  public var line: Int64 = 0

  /// Column number in source code.
  public var column: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes a function, including its human-readable name, system name,
/// source file, and starting line number in the source.
public struct Opentelemetry_Proto_Profiles_V1development_Function: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the function, in human-readable form if available.
  public var nameStrindex: Int32 = 0

  /// Name of the function, as identified by the system.
  /// For instance, it can be a C++ mangled name.
  public var systemNameStrindex: Int32 = 0

  /// Source file containing the function.
  public var filenameStrindex: Int32 = 0

  /// Line number in source file.
  public var startLine: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "opentelemetry.proto.profiles.v1development"

extension Opentelemetry_Proto_Profiles_V1development_AggregationTemporality: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AGGREGATION_TEMPORALITY_UNSPECIFIED"),
    1: .same(proto: "AGGREGATION_TEMPORALITY_DELTA"),
    2: .same(proto: "AGGREGATION_TEMPORALITY_CUMULATIVE"),
  ]
}

extension Opentelemetry_Proto_Profiles_V1development_ProfilesData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProfilesData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resource_profiles"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.resourceProfiles) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceProfiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resourceProfiles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_ProfilesData, rhs: Opentelemetry_Proto_Profiles_V1development_ProfilesData) -> Bool {
    if lhs.resourceProfiles != rhs.resourceProfiles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_ResourceProfiles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceProfiles"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resource"),
    2: .standard(proto: "scope_profiles"),
    3: .standard(proto: "schema_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.scopeProfiles) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.schemaURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.scopeProfiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.scopeProfiles, fieldNumber: 2)
    }
    if !self.schemaURL.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_ResourceProfiles, rhs: Opentelemetry_Proto_Profiles_V1development_ResourceProfiles) -> Bool {
    if lhs._resource != rhs._resource {return false}
    if lhs.scopeProfiles != rhs.scopeProfiles {return false}
    if lhs.schemaURL != rhs.schemaURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_ScopeProfiles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScopeProfiles"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
    2: .same(proto: "profiles"),
    3: .standard(proto: "schema_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._scope) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.profiles) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.schemaURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._scope {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.profiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.profiles, fieldNumber: 2)
    }
    if !self.schemaURL.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_ScopeProfiles, rhs: Opentelemetry_Proto_Profiles_V1development_ScopeProfiles) -> Bool {
    if lhs._scope != rhs._scope {return false}
    if lhs.profiles != rhs.profiles {return false}
    if lhs.schemaURL != rhs.schemaURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_Profile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Profile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_type"),
    2: .same(proto: "sample"),
    3: .standard(proto: "mapping_table"),
    4: .standard(proto: "location_table"),
    5: .standard(proto: "location_indices"),
    6: .standard(proto: "function_table"),
    7: .standard(proto: "attribute_table"),
    8: .standard(proto: "attribute_units"),
    9: .standard(proto: "link_table"),
    10: .standard(proto: "string_table"),
    11: .standard(proto: "time_nanos"),
    12: .standard(proto: "duration_nanos"),
    13: .standard(proto: "period_type"),
    14: .same(proto: "period"),
    15: .standard(proto: "comment_strindices"),
    16: .standard(proto: "default_sample_type_strindex"),
    17: .standard(proto: "profile_id"),
    19: .standard(proto: "dropped_attributes_count"),
    20: .standard(proto: "original_payload_format"),
    21: .standard(proto: "original_payload"),
    22: .standard(proto: "attribute_indices"),
  ]

  fileprivate class _StorageClass {
    var _sampleType: [Opentelemetry_Proto_Profiles_V1development_ValueType] = []
    var _sample: [Opentelemetry_Proto_Profiles_V1development_Sample] = []
    var _mappingTable: [Opentelemetry_Proto_Profiles_V1development_Mapping] = []
    var _locationTable: [Opentelemetry_Proto_Profiles_V1development_Location] = []
    var _locationIndices: [Int32] = []
    var _functionTable: [Opentelemetry_Proto_Profiles_V1development_Function] = []
    var _attributeTable: [Opentelemetry_Proto_Common_V1_KeyValue] = []
    var _attributeUnits: [Opentelemetry_Proto_Profiles_V1development_AttributeUnit] = []
    var _linkTable: [Opentelemetry_Proto_Profiles_V1development_Link] = []
    var _stringTable: [String] = []
    var _timeNanos: Int64 = 0
    var _durationNanos: Int64 = 0
    var _periodType: Opentelemetry_Proto_Profiles_V1development_ValueType? = nil
    var _period: Int64 = 0
    var _commentStrindices: [Int32] = []
    var _defaultSampleTypeStrindex: Int32 = 0
    var _profileID: Data = Data()
    var _droppedAttributesCount: UInt32 = 0
    var _originalPayloadFormat: String = String()
    var _originalPayload: Data = Data()
    var _attributeIndices: [Int32] = []

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _sampleType = source._sampleType
      _sample = source._sample
      _mappingTable = source._mappingTable
      _locationTable = source._locationTable
      _locationIndices = source._locationIndices
      _functionTable = source._functionTable
      _attributeTable = source._attributeTable
      _attributeUnits = source._attributeUnits
      _linkTable = source._linkTable
      _stringTable = source._stringTable
      _timeNanos = source._timeNanos
      _durationNanos = source._durationNanos
      _periodType = source._periodType
      _period = source._period
      _commentStrindices = source._commentStrindices
      _defaultSampleTypeStrindex = source._defaultSampleTypeStrindex
      _profileID = source._profileID
      _droppedAttributesCount = source._droppedAttributesCount
      _originalPayloadFormat = source._originalPayloadFormat
      _originalPayload = source._originalPayload
      _attributeIndices = source._attributeIndices
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._sampleType) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._sample) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._mappingTable) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._locationTable) }()
        case 5: try { try decoder.decodeRepeatedInt32Field(value: &_storage._locationIndices) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._functionTable) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._attributeTable) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._attributeUnits) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._linkTable) }()
        case 10: try { try decoder.decodeRepeatedStringField(value: &_storage._stringTable) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._timeNanos) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._durationNanos) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._periodType) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._period) }()
        case 15: try { try decoder.decodeRepeatedInt32Field(value: &_storage._commentStrindices) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._defaultSampleTypeStrindex) }()
        case 17: try { try decoder.decodeSingularBytesField(value: &_storage._profileID) }()
        case 19: try { try decoder.decodeSingularUInt32Field(value: &_storage._droppedAttributesCount) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._originalPayloadFormat) }()
        case 21: try { try decoder.decodeSingularBytesField(value: &_storage._originalPayload) }()
        case 22: try { try decoder.decodeRepeatedInt32Field(value: &_storage._attributeIndices) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._sampleType.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sampleType, fieldNumber: 1)
      }
      if !_storage._sample.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sample, fieldNumber: 2)
      }
      if !_storage._mappingTable.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._mappingTable, fieldNumber: 3)
      }
      if !_storage._locationTable.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._locationTable, fieldNumber: 4)
      }
      if !_storage._locationIndices.isEmpty {
        try visitor.visitPackedInt32Field(value: _storage._locationIndices, fieldNumber: 5)
      }
      if !_storage._functionTable.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._functionTable, fieldNumber: 6)
      }
      if !_storage._attributeTable.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._attributeTable, fieldNumber: 7)
      }
      if !_storage._attributeUnits.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._attributeUnits, fieldNumber: 8)
      }
      if !_storage._linkTable.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._linkTable, fieldNumber: 9)
      }
      if !_storage._stringTable.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._stringTable, fieldNumber: 10)
      }
      if _storage._timeNanos != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timeNanos, fieldNumber: 11)
      }
      if _storage._durationNanos != 0 {
        try visitor.visitSingularInt64Field(value: _storage._durationNanos, fieldNumber: 12)
      }
      try { if let v = _storage._periodType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if _storage._period != 0 {
        try visitor.visitSingularInt64Field(value: _storage._period, fieldNumber: 14)
      }
      if !_storage._commentStrindices.isEmpty {
        try visitor.visitPackedInt32Field(value: _storage._commentStrindices, fieldNumber: 15)
      }
      if _storage._defaultSampleTypeStrindex != 0 {
        try visitor.visitSingularInt32Field(value: _storage._defaultSampleTypeStrindex, fieldNumber: 16)
      }
      if !_storage._profileID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._profileID, fieldNumber: 17)
      }
      if _storage._droppedAttributesCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._droppedAttributesCount, fieldNumber: 19)
      }
      if !_storage._originalPayloadFormat.isEmpty {
        try visitor.visitSingularStringField(value: _storage._originalPayloadFormat, fieldNumber: 20)
      }
      if !_storage._originalPayload.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._originalPayload, fieldNumber: 21)
      }
      if !_storage._attributeIndices.isEmpty {
        try visitor.visitPackedInt32Field(value: _storage._attributeIndices, fieldNumber: 22)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_Profile, rhs: Opentelemetry_Proto_Profiles_V1development_Profile) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sampleType != rhs_storage._sampleType {return false}
        if _storage._sample != rhs_storage._sample {return false}
        if _storage._mappingTable != rhs_storage._mappingTable {return false}
        if _storage._locationTable != rhs_storage._locationTable {return false}
        if _storage._locationIndices != rhs_storage._locationIndices {return false}
        if _storage._functionTable != rhs_storage._functionTable {return false}
        if _storage._attributeTable != rhs_storage._attributeTable {return false}
        if _storage._attributeUnits != rhs_storage._attributeUnits {return false}
        if _storage._linkTable != rhs_storage._linkTable {return false}
        if _storage._stringTable != rhs_storage._stringTable {return false}
        if _storage._timeNanos != rhs_storage._timeNanos {return false}
        if _storage._durationNanos != rhs_storage._durationNanos {return false}
        if _storage._periodType != rhs_storage._periodType {return false}
        if _storage._period != rhs_storage._period {return false}
        if _storage._commentStrindices != rhs_storage._commentStrindices {return false}
        if _storage._defaultSampleTypeStrindex != rhs_storage._defaultSampleTypeStrindex {return false}
        if _storage._profileID != rhs_storage._profileID {return false}
        if _storage._droppedAttributesCount != rhs_storage._droppedAttributesCount {return false}
        if _storage._originalPayloadFormat != rhs_storage._originalPayloadFormat {return false}
        if _storage._originalPayload != rhs_storage._originalPayload {return false}
        if _storage._attributeIndices != rhs_storage._attributeIndices {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_AttributeUnit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AttributeUnit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "attribute_key_strindex"),
    2: .standard(proto: "unit_strindex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.attributeKeyStrindex) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.unitStrindex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.attributeKeyStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.attributeKeyStrindex, fieldNumber: 1)
    }
    if self.unitStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.unitStrindex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_AttributeUnit, rhs: Opentelemetry_Proto_Profiles_V1development_AttributeUnit) -> Bool {
    if lhs.attributeKeyStrindex != rhs.attributeKeyStrindex {return false}
    if lhs.unitStrindex != rhs.unitStrindex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_Link: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Link"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trace_id"),
    2: .standard(proto: "span_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.traceID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.spanID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.traceID.isEmpty {
      try visitor.visitSingularBytesField(value: self.traceID, fieldNumber: 1)
    }
    if !self.spanID.isEmpty {
      try visitor.visitSingularBytesField(value: self.spanID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_Link, rhs: Opentelemetry_Proto_Profiles_V1development_Link) -> Bool {
    if lhs.traceID != rhs.traceID {return false}
    if lhs.spanID != rhs.spanID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_ValueType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValueType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "type_strindex"),
    2: .standard(proto: "unit_strindex"),
    3: .standard(proto: "aggregation_temporality"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.typeStrindex) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.unitStrindex) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.aggregationTemporality) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.typeStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.typeStrindex, fieldNumber: 1)
    }
    if self.unitStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.unitStrindex, fieldNumber: 2)
    }
    if self.aggregationTemporality != .unspecified {
      try visitor.visitSingularEnumField(value: self.aggregationTemporality, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_ValueType, rhs: Opentelemetry_Proto_Profiles_V1development_ValueType) -> Bool {
    if lhs.typeStrindex != rhs.typeStrindex {return false}
    if lhs.unitStrindex != rhs.unitStrindex {return false}
    if lhs.aggregationTemporality != rhs.aggregationTemporality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_Sample: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Sample"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "locations_start_index"),
    2: .standard(proto: "locations_length"),
    3: .same(proto: "value"),
    4: .standard(proto: "attribute_indices"),
    5: .standard(proto: "link_index"),
    6: .standard(proto: "timestamps_unix_nano"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.locationsStartIndex) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.locationsLength) }()
      case 3: try { try decoder.decodeRepeatedInt64Field(value: &self.value) }()
      case 4: try { try decoder.decodeRepeatedInt32Field(value: &self.attributeIndices) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._linkIndex) }()
      case 6: try { try decoder.decodeRepeatedUInt64Field(value: &self.timestampsUnixNano) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.locationsStartIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.locationsStartIndex, fieldNumber: 1)
    }
    if self.locationsLength != 0 {
      try visitor.visitSingularInt32Field(value: self.locationsLength, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitPackedInt64Field(value: self.value, fieldNumber: 3)
    }
    if !self.attributeIndices.isEmpty {
      try visitor.visitPackedInt32Field(value: self.attributeIndices, fieldNumber: 4)
    }
    try { if let v = self._linkIndex {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    if !self.timestampsUnixNano.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.timestampsUnixNano, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_Sample, rhs: Opentelemetry_Proto_Profiles_V1development_Sample) -> Bool {
    if lhs.locationsStartIndex != rhs.locationsStartIndex {return false}
    if lhs.locationsLength != rhs.locationsLength {return false}
    if lhs.value != rhs.value {return false}
    if lhs.attributeIndices != rhs.attributeIndices {return false}
    if lhs._linkIndex != rhs._linkIndex {return false}
    if lhs.timestampsUnixNano != rhs.timestampsUnixNano {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_Mapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Mapping"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "memory_start"),
    2: .standard(proto: "memory_limit"),
    3: .standard(proto: "file_offset"),
    4: .standard(proto: "filename_strindex"),
    5: .standard(proto: "attribute_indices"),
    6: .standard(proto: "has_functions"),
    7: .standard(proto: "has_filenames"),
    8: .standard(proto: "has_line_numbers"),
    9: .standard(proto: "has_inline_frames"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.memoryStart) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.memoryLimit) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.fileOffset) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.filenameStrindex) }()
      case 5: try { try decoder.decodeRepeatedInt32Field(value: &self.attributeIndices) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.hasFunctions_p) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.hasFilenames_p) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.hasLineNumbers_p) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.hasInlineFrames_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.memoryStart != 0 {
      try visitor.visitSingularUInt64Field(value: self.memoryStart, fieldNumber: 1)
    }
    if self.memoryLimit != 0 {
      try visitor.visitSingularUInt64Field(value: self.memoryLimit, fieldNumber: 2)
    }
    if self.fileOffset != 0 {
      try visitor.visitSingularUInt64Field(value: self.fileOffset, fieldNumber: 3)
    }
    if self.filenameStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.filenameStrindex, fieldNumber: 4)
    }
    if !self.attributeIndices.isEmpty {
      try visitor.visitPackedInt32Field(value: self.attributeIndices, fieldNumber: 5)
    }
    if self.hasFunctions_p != false {
      try visitor.visitSingularBoolField(value: self.hasFunctions_p, fieldNumber: 6)
    }
    if self.hasFilenames_p != false {
      try visitor.visitSingularBoolField(value: self.hasFilenames_p, fieldNumber: 7)
    }
    if self.hasLineNumbers_p != false {
      try visitor.visitSingularBoolField(value: self.hasLineNumbers_p, fieldNumber: 8)
    }
    if self.hasInlineFrames_p != false {
      try visitor.visitSingularBoolField(value: self.hasInlineFrames_p, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_Mapping, rhs: Opentelemetry_Proto_Profiles_V1development_Mapping) -> Bool {
    if lhs.memoryStart != rhs.memoryStart {return false}
    if lhs.memoryLimit != rhs.memoryLimit {return false}
    if lhs.fileOffset != rhs.fileOffset {return false}
    if lhs.filenameStrindex != rhs.filenameStrindex {return false}
    if lhs.attributeIndices != rhs.attributeIndices {return false}
    if lhs.hasFunctions_p != rhs.hasFunctions_p {return false}
    if lhs.hasFilenames_p != rhs.hasFilenames_p {return false}
    if lhs.hasLineNumbers_p != rhs.hasLineNumbers_p {return false}
    if lhs.hasInlineFrames_p != rhs.hasInlineFrames_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Location"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mapping_index"),
    2: .same(proto: "address"),
    3: .same(proto: "line"),
    4: .standard(proto: "is_folded"),
    5: .standard(proto: "attribute_indices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._mappingIndex) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.line) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isFolded) }()
      case 5: try { try decoder.decodeRepeatedInt32Field(value: &self.attributeIndices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mappingIndex {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 2)
    }
    if !self.line.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.line, fieldNumber: 3)
    }
    if self.isFolded != false {
      try visitor.visitSingularBoolField(value: self.isFolded, fieldNumber: 4)
    }
    if !self.attributeIndices.isEmpty {
      try visitor.visitPackedInt32Field(value: self.attributeIndices, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_Location, rhs: Opentelemetry_Proto_Profiles_V1development_Location) -> Bool {
    if lhs._mappingIndex != rhs._mappingIndex {return false}
    if lhs.address != rhs.address {return false}
    if lhs.line != rhs.line {return false}
    if lhs.isFolded != rhs.isFolded {return false}
    if lhs.attributeIndices != rhs.attributeIndices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_Line: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Line"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "function_index"),
    2: .same(proto: "line"),
    3: .same(proto: "column"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.functionIndex) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.line) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.column) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.functionIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.functionIndex, fieldNumber: 1)
    }
    if self.line != 0 {
      try visitor.visitSingularInt64Field(value: self.line, fieldNumber: 2)
    }
    if self.column != 0 {
      try visitor.visitSingularInt64Field(value: self.column, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_Line, rhs: Opentelemetry_Proto_Profiles_V1development_Line) -> Bool {
    if lhs.functionIndex != rhs.functionIndex {return false}
    if lhs.line != rhs.line {return false}
    if lhs.column != rhs.column {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_Function: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Function"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "name_strindex"),
    2: .standard(proto: "system_name_strindex"),
    3: .standard(proto: "filename_strindex"),
    4: .standard(proto: "start_line"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.nameStrindex) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.systemNameStrindex) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.filenameStrindex) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.startLine) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nameStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.nameStrindex, fieldNumber: 1)
    }
    if self.systemNameStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.systemNameStrindex, fieldNumber: 2)
    }
    if self.filenameStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.filenameStrindex, fieldNumber: 3)
    }
    if self.startLine != 0 {
      try visitor.visitSingularInt64Field(value: self.startLine, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_Function, rhs: Opentelemetry_Proto_Profiles_V1development_Function) -> Bool {
    if lhs.nameStrindex != rhs.nameStrindex {return false}
    if lhs.systemNameStrindex != rhs.systemNameStrindex {return false}
    if lhs.filenameStrindex != rhs.filenameStrindex {return false}
    if lhs.startLine != rhs.startLine {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
