// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: opentelemetry/proto/profiles/v1development/profiles.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2023, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// This file includes work covered by the following copyright and permission notices:
//
// Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Specifies the method of aggregating metric values, either DELTA (change since last report)
/// or CUMULATIVE (total since a fixed start time).
public enum Opentelemetry_Proto_Profiles_V1development_AggregationTemporality: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// UNSPECIFIED is the default AggregationTemporality, it MUST not be used. 
  case unspecified // = 0

  ///* DELTA is an AggregationTemporality for a profiler which reports
  ///changes since last report time. Successive metrics contain aggregation of
  ///values from continuous and non-overlapping intervals.
  ///
  ///The values for a DELTA metric are based only on the time interval
  ///associated with one measurement cycle. There is no dependency on
  ///previous measurements like is the case for CUMULATIVE metrics.
  ///
  ///For example, consider a system measuring the number of requests that
  ///it receives and reports the sum of these requests every second as a
  ///DELTA metric:
  ///
  ///1. The system starts receiving at time=t_0.
  ///2. A request is received, the system measures 1 request.
  ///3. A request is received, the system measures 1 request.
  ///4. A request is received, the system measures 1 request.
  ///5. The 1 second collection cycle ends. A metric is exported for the
  ///number of requests received over the interval of time t_0 to
  ///t_0+1 with a value of 3.
  ///6. A request is received, the system measures 1 request.
  ///7. A request is received, the system measures 1 request.
  ///8. The 1 second collection cycle ends. A metric is exported for the
  ///number of requests received over the interval of time t_0+1 to
  ///t_0+2 with a value of 2. 
  case delta // = 1

  ///* CUMULATIVE is an AggregationTemporality for a profiler which
  ///reports changes since a fixed start time. This means that current values
  ///of a CUMULATIVE metric depend on all previous measurements since the
  ///start time. Because of this, the sender is required to retain this state
  ///in some form. If this state is lost or invalidated, the CUMULATIVE metric
  ///values MUST be reset and a new fixed start time following the last
  ///reported measurement time sent MUST be used.
  ///
  ///For example, consider a system measuring the number of requests that
  ///it receives and reports the sum of these requests every second as a
  ///CUMULATIVE metric:
  ///
  ///1. The system starts receiving at time=t_0.
  ///2. A request is received, the system measures 1 request.
  ///3. A request is received, the system measures 1 request.
  ///4. A request is received, the system measures 1 request.
  ///5. The 1 second collection cycle ends. A metric is exported for the
  ///number of requests received over the interval of time t_0 to
  ///t_0+1 with a value of 3.
  ///6. A request is received, the system measures 1 request.
  ///7. A request is received, the system measures 1 request.
  ///8. The 1 second collection cycle ends. A metric is exported for the
  ///number of requests received over the interval of time t_0 to
  ///t_0+2 with a value of 5.
  ///9. The system experiences a fault and loses state.
  ///10. The system recovers and resumes receiving at time=t_1.
  ///11. A request is received, the system measures 1 request.
  ///12. The 1 second collection cycle ends. A metric is exported for the
  ///number of requests received over the interval of time t_1 to
  ///t_1+1 with a value of 1.
  ///
  ///Note: Even though, when reporting changes since last report time, using
  ///CUMULATIVE is valid, it is not recommended. 
  case cumulative // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .delta
    case 2: self = .cumulative
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .delta: return 1
    case .cumulative: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Opentelemetry_Proto_Profiles_V1development_AggregationTemporality] = [
    .unspecified,
    .delta,
    .cumulative,
  ]

}

/// ProfilesData represents the profiles data that can be stored in persistent storage,
/// OR can be embedded by other protocols that transfer OTLP profiles data but do not
/// implement the OTLP protocol.
///
/// The main difference between this message and collector protocol is that
/// in this message there will not be any "control" or "metadata" specific to
/// OTLP protocol.
///
/// When new fields are added into this message, the OTLP request MUST be updated
/// as well.
public struct Opentelemetry_Proto_Profiles_V1development_ProfilesData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An array of ResourceProfiles.
  /// For data coming from an SDK profiler, this array will typically contain one
  /// element. Host-level profilers will usually create one ResourceProfile per
  /// container, as well as one additional ResourceProfile grouping all samples
  /// from non-containerized processes.
  /// Other resource groupings are possible as well and clarified via
  /// Resource.attributes and semantic conventions.
  public var resourceProfiles: [Opentelemetry_Proto_Profiles_V1development_ResourceProfiles] = []

  /// Mappings from address ranges to the image/binary/library mapped
  /// into that address range referenced by locations via Location.mapping_index.
  public var mappingTable: [Opentelemetry_Proto_Profiles_V1development_Mapping] = []

  /// Locations referenced by samples via Profile.location_indices.
  public var locationTable: [Opentelemetry_Proto_Profiles_V1development_Location] = []

  /// Functions referenced by locations via Line.function_index.
  public var functionTable: [Opentelemetry_Proto_Profiles_V1development_Function] = []

  /// Links referenced by samples via Sample.link_index.
  public var linkTable: [Opentelemetry_Proto_Profiles_V1development_Link] = []

  /// A common table for strings referenced by various messages.
  /// string_table[0] must always be "".
  public var stringTable: [String] = []

  /// A common table for attributes referenced by various messages.
  public var attributeTable: [Opentelemetry_Proto_Common_V1_KeyValue] = []

  /// Represents a mapping between Attribute Keys and Units.
  public var attributeUnits: [Opentelemetry_Proto_Profiles_V1development_AttributeUnit] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A collection of ScopeProfiles from a Resource.
public struct Opentelemetry_Proto_Profiles_V1development_ResourceProfiles: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource for the profiles in this message.
  /// If this field is not set then no resource info is known.
  public var resource: Opentelemetry_Proto_Resource_V1_Resource {
    get {return _resource ?? Opentelemetry_Proto_Resource_V1_Resource()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  /// A list of ScopeProfiles that originate from a resource.
  public var scopeProfiles: [Opentelemetry_Proto_Profiles_V1development_ScopeProfiles] = []

  /// The Schema URL, if known. This is the identifier of the Schema that the resource data
  /// is recorded in. Notably, the last part of the URL path is the version number of the
  /// schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
  /// https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
  /// This schema_url applies to the data in the "resource" field. It does not apply
  /// to the data in the "scope_profiles" field which have their own schema_url field.
  public var schemaURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _resource: Opentelemetry_Proto_Resource_V1_Resource? = nil
}

/// A collection of Profiles produced by an InstrumentationScope.
public struct Opentelemetry_Proto_Profiles_V1development_ScopeProfiles: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instrumentation scope information for the profiles in this message.
  /// Semantically when InstrumentationScope isn't set, it is equivalent with
  /// an empty instrumentation scope name (unknown).
  public var scope: Opentelemetry_Proto_Common_V1_InstrumentationScope {
    get {return _scope ?? Opentelemetry_Proto_Common_V1_InstrumentationScope()}
    set {_scope = newValue}
  }
  /// Returns true if `scope` has been explicitly set.
  public var hasScope: Bool {return self._scope != nil}
  /// Clears the value of `scope`. Subsequent reads from it will return its default value.
  public mutating func clearScope() {self._scope = nil}

  /// A list of Profiles that originate from an instrumentation scope.
  public var profiles: [Opentelemetry_Proto_Profiles_V1development_Profile] = []

  /// The Schema URL, if known. This is the identifier of the Schema that the profile data
  /// is recorded in. Notably, the last part of the URL path is the version number of the
  /// schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
  /// https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
  /// This schema_url applies to all profiles in the "profiles" field.
  public var schemaURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _scope: Opentelemetry_Proto_Common_V1_InstrumentationScope? = nil
}

/// Represents a complete profile, including sample types, samples,
/// mappings to binaries, locations, functions, string table, and additional metadata.
/// It modifies and annotates pprof Profile with OpenTelemetry specific fields.
///
/// Note that whilst fields in this message retain the name and field id from pprof in most cases
/// for ease of understanding data migration, it is not intended that pprof:Profile and
/// OpenTelemetry:Profile encoding be wire compatible.
public struct Opentelemetry_Proto_Profiles_V1development_Profile: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A description of the samples associated with each Sample.value.
  /// For a cpu profile this might be:
  ///   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
  /// For a heap profile, this might be:
  ///   [["allocations","count"], ["space","bytes"]],
  /// If one of the values represents the number of events represented
  /// by the sample, by convention it should be at index 0 and use
  /// sample_type.unit == "count".
  public var sampleType: [Opentelemetry_Proto_Profiles_V1development_ValueType] = []

  /// The set of samples recorded in this profile.
  public var sample: [Opentelemetry_Proto_Profiles_V1development_Sample] = []

  /// References to locations in ProfilesData.location_table.
  public var locationIndices: [Int32] = []

  /// Time of collection (UTC) represented as nanoseconds past the epoch.
  public var timeNanos: Int64 = 0

  /// Duration of the profile, if a duration makes sense.
  public var durationNanos: Int64 = 0

  /// The kind of events between sampled occurrences.
  /// e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
  public var periodType: Opentelemetry_Proto_Profiles_V1development_ValueType {
    get {return _periodType ?? Opentelemetry_Proto_Profiles_V1development_ValueType()}
    set {_periodType = newValue}
  }
  /// Returns true if `periodType` has been explicitly set.
  public var hasPeriodType: Bool {return self._periodType != nil}
  /// Clears the value of `periodType`. Subsequent reads from it will return its default value.
  public mutating func clearPeriodType() {self._periodType = nil}

  /// The number of events between sampled occurrences.
  public var period: Int64 = 0

  /// Free-form text associated with the profile. The text is displayed as is
  /// to the user by the tools that read profiles (e.g. by pprof). This field
  /// should not be used to store any machine-readable information, it is only
  /// for human-friendly content. The profile must stay functional if this field
  /// is cleaned.
  public var commentStrindices: [Int32] = []

  /// Index into the sample_type array to the default sample type.
  public var defaultSampleTypeIndex: Int32 = 0

  /// A globally unique identifier for a profile. The ID is a 16-byte array. An ID with
  /// all zeroes is considered invalid.
  ///
  /// This field is required.
  public var profileID: Data = Data()

  /// dropped_attributes_count is the number of attributes that were discarded. Attributes
  /// can be discarded because their keys are too long or because there are too many
  /// attributes. If this value is 0, then no attributes were dropped.
  public var droppedAttributesCount: UInt32 = 0

  /// Specifies format of the original payload. Common values are defined in semantic conventions. [required if original_payload is present]
  public var originalPayloadFormat: String = String()

  /// Original payload can be stored in this field. This can be useful for users who want to get the original payload.
  /// Formats such as JFR are highly extensible and can contain more information than what is defined in this spec.
  /// Inclusion of original payload should be configurable by the user. Default behavior should be to not include the original payload.
  /// If the original payload is in pprof format, it SHOULD not be included in this field.
  /// The field is optional, however if it is present then equivalent converted data should be populated in other fields
  /// of this message as far as is practicable.
  public var originalPayload: Data = Data()

  /// References to attributes in attribute_table. [optional]
  /// It is a collection of key/value pairs. Note, global attributes
  /// like server name can be set using the resource API. Examples of attributes:
  ///
  ///     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
  ///     "/http/server_latency": 300
  ///     "abc.com/myattribute": true
  ///     "abc.com/score": 10.239
  ///
  /// The OpenTelemetry API specification further restricts the allowed value types:
  /// https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/README.md#attribute
  /// Attribute keys MUST be unique (it is not allowed to have more than one
  /// attribute with the same key).
  public var attributeIndices: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _periodType: Opentelemetry_Proto_Profiles_V1development_ValueType? = nil
}

/// Represents a mapping between Attribute Keys and Units.
public struct Opentelemetry_Proto_Profiles_V1development_AttributeUnit: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Index into string table.
  public var attributeKeyStrindex: Int32 = 0

  /// Index into string table.
  public var unitStrindex: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A pointer from a profile Sample to a trace Span.
/// Connects a profile sample to a trace span, identified by unique trace and span IDs.
public struct Opentelemetry_Proto_Profiles_V1development_Link: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier of a trace that this linked span is part of. The ID is a
  /// 16-byte array.
  public var traceID: Data = Data()

  /// A unique identifier for the linked span. The ID is an 8-byte array.
  public var spanID: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ValueType describes the type and units of a value, with an optional aggregation temporality.
public struct Opentelemetry_Proto_Profiles_V1development_ValueType: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Index into ProfilesData.string_table.
  public var typeStrindex: Int32 = 0

  /// Index into ProfilesData.string_table.
  public var unitStrindex: Int32 = 0

  public var aggregationTemporality: Opentelemetry_Proto_Profiles_V1development_AggregationTemporality = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Each Sample records values encountered in some program
/// context. The program context is typically a stack trace, perhaps
/// augmented with auxiliary information like the thread-id, some
/// indicator of a higher level request being handled etc.
public struct Opentelemetry_Proto_Profiles_V1development_Sample: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// locations_start_index along with locations_length refers to to a slice of locations in Profile.location_indices.
  public var locationsStartIndex: Int32 = 0

  /// locations_length along with locations_start_index refers to a slice of locations in Profile.location_indices.
  /// Supersedes location_index.
  public var locationsLength: Int32 = 0

  /// The type and unit of each value is defined by the corresponding
  /// entry in Profile.sample_type. All samples must have the same
  /// number of values, the same as the length of Profile.sample_type.
  /// When aggregating multiple samples into a single sample, the
  /// result has a list of values that is the element-wise sum of the
  /// lists of the originals.
  public var value: [Int64] = []

  /// References to attributes in ProfilesData.attribute_table. [optional]
  public var attributeIndices: [Int32] = []

  /// Reference to link in ProfilesData.link_table. [optional]
  public var linkIndex: Int32 {
    get {return _linkIndex ?? 0}
    set {_linkIndex = newValue}
  }
  /// Returns true if `linkIndex` has been explicitly set.
  public var hasLinkIndex: Bool {return self._linkIndex != nil}
  /// Clears the value of `linkIndex`. Subsequent reads from it will return its default value.
  public mutating func clearLinkIndex() {self._linkIndex = nil}

  /// Timestamps associated with Sample represented in nanoseconds. These timestamps are expected
  /// to fall within the Profile's time range. [optional]
  public var timestampsUnixNano: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _linkIndex: Int32? = nil
}

/// Describes the mapping of a binary in memory, including its address range,
/// file offset, and metadata like build ID
public struct Opentelemetry_Proto_Profiles_V1development_Mapping: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Address at which the binary (or DLL) is loaded into memory.
  public var memoryStart: UInt64 = 0

  /// The limit of the address range occupied by this mapping.
  public var memoryLimit: UInt64 = 0

  /// Offset in the binary that corresponds to the first mapped address.
  public var fileOffset: UInt64 = 0

  /// The object this entry is loaded from.  This can be a filename on
  /// disk for the main binary and shared libraries, or virtual
  /// abstractions like "[vdso]".
  public var filenameStrindex: Int32 = 0

  /// References to attributes in ProfilesData.attribute_table. [optional]
  public var attributeIndices: [Int32] = []

  /// The following fields indicate the resolution of symbolic info.
  public var hasFunctions_p: Bool = false

  public var hasFilenames_p: Bool = false

  public var hasLineNumbers_p: Bool = false

  public var hasInlineFrames_p: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes function and line table debug information.
public struct Opentelemetry_Proto_Profiles_V1development_Location: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Reference to mapping in ProfilesData.mapping_table.
  /// It can be unset if the mapping is unknown or not applicable for
  /// this profile type.
  public var mappingIndex: Int32 {
    get {return _mappingIndex ?? 0}
    set {_mappingIndex = newValue}
  }
  /// Returns true if `mappingIndex` has been explicitly set.
  public var hasMappingIndex: Bool {return self._mappingIndex != nil}
  /// Clears the value of `mappingIndex`. Subsequent reads from it will return its default value.
  public mutating func clearMappingIndex() {self._mappingIndex = nil}

  /// The instruction address for this location, if available.  It
  /// should be within [Mapping.memory_start...Mapping.memory_limit]
  /// for the corresponding mapping. A non-leaf address may be in the
  /// middle of a call instruction. It is up to display tools to find
  /// the beginning of the instruction if necessary.
  public var address: UInt64 = 0

  /// Multiple line indicates this location has inlined functions,
  /// where the last entry represents the caller into which the
  /// preceding entries were inlined.
  ///
  /// E.g., if memcpy() is inlined into printf:
  ///    line[0].function_name == "memcpy"
  ///    line[1].function_name == "printf"
  public var line: [Opentelemetry_Proto_Profiles_V1development_Line] = []

  /// Provides an indication that multiple symbols map to this location's
  /// address, for example due to identical code folding by the linker. In that
  /// case the line information above represents one of the multiple
  /// symbols. This field must be recomputed when the symbolization state of the
  /// profile changes.
  public var isFolded: Bool = false

  /// References to attributes in ProfilesData.attribute_table. [optional]
  public var attributeIndices: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _mappingIndex: Int32? = nil
}

/// Details a specific line in a source code, linked to a function.
public struct Opentelemetry_Proto_Profiles_V1development_Line: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Reference to function in ProfilesData.function_table.
  public var functionIndex: Int32 = 0

  /// Line number in source code. 0 means unset.
  public var line: Int64 = 0

  /// Column number in source code. 0 means unset.
  public var column: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes a function, including its human-readable name, system name,
/// source file, and starting line number in the source.
public struct Opentelemetry_Proto_Profiles_V1development_Function: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Function name. Empty string if not available.
  public var nameStrindex: Int32 = 0

  /// Function name, as identified by the system. For instance,
  /// it can be a C++ mangled name. Empty string if not available.
  public var systemNameStrindex: Int32 = 0

  /// Source file containing the function. Empty string if not available.
  public var filenameStrindex: Int32 = 0

  /// Line number in source file. 0 means unset.
  public var startLine: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "opentelemetry.proto.profiles.v1development"

extension Opentelemetry_Proto_Profiles_V1development_AggregationTemporality: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AGGREGATION_TEMPORALITY_UNSPECIFIED"),
    1: .same(proto: "AGGREGATION_TEMPORALITY_DELTA"),
    2: .same(proto: "AGGREGATION_TEMPORALITY_CUMULATIVE"),
  ]
}

extension Opentelemetry_Proto_Profiles_V1development_ProfilesData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProfilesData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resource_profiles"),
    2: .standard(proto: "mapping_table"),
    3: .standard(proto: "location_table"),
    4: .standard(proto: "function_table"),
    5: .standard(proto: "link_table"),
    6: .standard(proto: "string_table"),
    7: .standard(proto: "attribute_table"),
    8: .standard(proto: "attribute_units"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.resourceProfiles) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.mappingTable) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.locationTable) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.functionTable) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.linkTable) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.stringTable) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.attributeTable) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.attributeUnits) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceProfiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resourceProfiles, fieldNumber: 1)
    }
    if !self.mappingTable.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mappingTable, fieldNumber: 2)
    }
    if !self.locationTable.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.locationTable, fieldNumber: 3)
    }
    if !self.functionTable.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.functionTable, fieldNumber: 4)
    }
    if !self.linkTable.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.linkTable, fieldNumber: 5)
    }
    if !self.stringTable.isEmpty {
      try visitor.visitRepeatedStringField(value: self.stringTable, fieldNumber: 6)
    }
    if !self.attributeTable.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attributeTable, fieldNumber: 7)
    }
    if !self.attributeUnits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attributeUnits, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_ProfilesData, rhs: Opentelemetry_Proto_Profiles_V1development_ProfilesData) -> Bool {
    if lhs.resourceProfiles != rhs.resourceProfiles {return false}
    if lhs.mappingTable != rhs.mappingTable {return false}
    if lhs.locationTable != rhs.locationTable {return false}
    if lhs.functionTable != rhs.functionTable {return false}
    if lhs.linkTable != rhs.linkTable {return false}
    if lhs.stringTable != rhs.stringTable {return false}
    if lhs.attributeTable != rhs.attributeTable {return false}
    if lhs.attributeUnits != rhs.attributeUnits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_ResourceProfiles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceProfiles"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resource"),
    2: .standard(proto: "scope_profiles"),
    3: .standard(proto: "schema_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.scopeProfiles) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.schemaURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.scopeProfiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.scopeProfiles, fieldNumber: 2)
    }
    if !self.schemaURL.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_ResourceProfiles, rhs: Opentelemetry_Proto_Profiles_V1development_ResourceProfiles) -> Bool {
    if lhs._resource != rhs._resource {return false}
    if lhs.scopeProfiles != rhs.scopeProfiles {return false}
    if lhs.schemaURL != rhs.schemaURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_ScopeProfiles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScopeProfiles"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
    2: .same(proto: "profiles"),
    3: .standard(proto: "schema_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._scope) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.profiles) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.schemaURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._scope {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.profiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.profiles, fieldNumber: 2)
    }
    if !self.schemaURL.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_ScopeProfiles, rhs: Opentelemetry_Proto_Profiles_V1development_ScopeProfiles) -> Bool {
    if lhs._scope != rhs._scope {return false}
    if lhs.profiles != rhs.profiles {return false}
    if lhs.schemaURL != rhs.schemaURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_Profile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Profile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_type"),
    2: .same(proto: "sample"),
    3: .standard(proto: "location_indices"),
    4: .standard(proto: "time_nanos"),
    5: .standard(proto: "duration_nanos"),
    6: .standard(proto: "period_type"),
    7: .same(proto: "period"),
    8: .standard(proto: "comment_strindices"),
    9: .standard(proto: "default_sample_type_index"),
    10: .standard(proto: "profile_id"),
    11: .standard(proto: "dropped_attributes_count"),
    12: .standard(proto: "original_payload_format"),
    13: .standard(proto: "original_payload"),
    14: .standard(proto: "attribute_indices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sampleType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.sample) }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.locationIndices) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timeNanos) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.durationNanos) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._periodType) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.period) }()
      case 8: try { try decoder.decodeRepeatedInt32Field(value: &self.commentStrindices) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.defaultSampleTypeIndex) }()
      case 10: try { try decoder.decodeSingularBytesField(value: &self.profileID) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self.droppedAttributesCount) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.originalPayloadFormat) }()
      case 13: try { try decoder.decodeSingularBytesField(value: &self.originalPayload) }()
      case 14: try { try decoder.decodeRepeatedInt32Field(value: &self.attributeIndices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sampleType.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sampleType, fieldNumber: 1)
    }
    if !self.sample.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sample, fieldNumber: 2)
    }
    if !self.locationIndices.isEmpty {
      try visitor.visitPackedInt32Field(value: self.locationIndices, fieldNumber: 3)
    }
    if self.timeNanos != 0 {
      try visitor.visitSingularInt64Field(value: self.timeNanos, fieldNumber: 4)
    }
    if self.durationNanos != 0 {
      try visitor.visitSingularInt64Field(value: self.durationNanos, fieldNumber: 5)
    }
    try { if let v = self._periodType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.period != 0 {
      try visitor.visitSingularInt64Field(value: self.period, fieldNumber: 7)
    }
    if !self.commentStrindices.isEmpty {
      try visitor.visitPackedInt32Field(value: self.commentStrindices, fieldNumber: 8)
    }
    if self.defaultSampleTypeIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.defaultSampleTypeIndex, fieldNumber: 9)
    }
    if !self.profileID.isEmpty {
      try visitor.visitSingularBytesField(value: self.profileID, fieldNumber: 10)
    }
    if self.droppedAttributesCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.droppedAttributesCount, fieldNumber: 11)
    }
    if !self.originalPayloadFormat.isEmpty {
      try visitor.visitSingularStringField(value: self.originalPayloadFormat, fieldNumber: 12)
    }
    if !self.originalPayload.isEmpty {
      try visitor.visitSingularBytesField(value: self.originalPayload, fieldNumber: 13)
    }
    if !self.attributeIndices.isEmpty {
      try visitor.visitPackedInt32Field(value: self.attributeIndices, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_Profile, rhs: Opentelemetry_Proto_Profiles_V1development_Profile) -> Bool {
    if lhs.sampleType != rhs.sampleType {return false}
    if lhs.sample != rhs.sample {return false}
    if lhs.locationIndices != rhs.locationIndices {return false}
    if lhs.timeNanos != rhs.timeNanos {return false}
    if lhs.durationNanos != rhs.durationNanos {return false}
    if lhs._periodType != rhs._periodType {return false}
    if lhs.period != rhs.period {return false}
    if lhs.commentStrindices != rhs.commentStrindices {return false}
    if lhs.defaultSampleTypeIndex != rhs.defaultSampleTypeIndex {return false}
    if lhs.profileID != rhs.profileID {return false}
    if lhs.droppedAttributesCount != rhs.droppedAttributesCount {return false}
    if lhs.originalPayloadFormat != rhs.originalPayloadFormat {return false}
    if lhs.originalPayload != rhs.originalPayload {return false}
    if lhs.attributeIndices != rhs.attributeIndices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_AttributeUnit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AttributeUnit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "attribute_key_strindex"),
    2: .standard(proto: "unit_strindex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.attributeKeyStrindex) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.unitStrindex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.attributeKeyStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.attributeKeyStrindex, fieldNumber: 1)
    }
    if self.unitStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.unitStrindex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_AttributeUnit, rhs: Opentelemetry_Proto_Profiles_V1development_AttributeUnit) -> Bool {
    if lhs.attributeKeyStrindex != rhs.attributeKeyStrindex {return false}
    if lhs.unitStrindex != rhs.unitStrindex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_Link: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Link"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trace_id"),
    2: .standard(proto: "span_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.traceID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.spanID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.traceID.isEmpty {
      try visitor.visitSingularBytesField(value: self.traceID, fieldNumber: 1)
    }
    if !self.spanID.isEmpty {
      try visitor.visitSingularBytesField(value: self.spanID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_Link, rhs: Opentelemetry_Proto_Profiles_V1development_Link) -> Bool {
    if lhs.traceID != rhs.traceID {return false}
    if lhs.spanID != rhs.spanID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_ValueType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValueType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "type_strindex"),
    2: .standard(proto: "unit_strindex"),
    3: .standard(proto: "aggregation_temporality"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.typeStrindex) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.unitStrindex) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.aggregationTemporality) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.typeStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.typeStrindex, fieldNumber: 1)
    }
    if self.unitStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.unitStrindex, fieldNumber: 2)
    }
    if self.aggregationTemporality != .unspecified {
      try visitor.visitSingularEnumField(value: self.aggregationTemporality, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_ValueType, rhs: Opentelemetry_Proto_Profiles_V1development_ValueType) -> Bool {
    if lhs.typeStrindex != rhs.typeStrindex {return false}
    if lhs.unitStrindex != rhs.unitStrindex {return false}
    if lhs.aggregationTemporality != rhs.aggregationTemporality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_Sample: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Sample"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "locations_start_index"),
    2: .standard(proto: "locations_length"),
    3: .same(proto: "value"),
    4: .standard(proto: "attribute_indices"),
    5: .standard(proto: "link_index"),
    6: .standard(proto: "timestamps_unix_nano"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.locationsStartIndex) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.locationsLength) }()
      case 3: try { try decoder.decodeRepeatedInt64Field(value: &self.value) }()
      case 4: try { try decoder.decodeRepeatedInt32Field(value: &self.attributeIndices) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._linkIndex) }()
      case 6: try { try decoder.decodeRepeatedUInt64Field(value: &self.timestampsUnixNano) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.locationsStartIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.locationsStartIndex, fieldNumber: 1)
    }
    if self.locationsLength != 0 {
      try visitor.visitSingularInt32Field(value: self.locationsLength, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitPackedInt64Field(value: self.value, fieldNumber: 3)
    }
    if !self.attributeIndices.isEmpty {
      try visitor.visitPackedInt32Field(value: self.attributeIndices, fieldNumber: 4)
    }
    try { if let v = self._linkIndex {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    if !self.timestampsUnixNano.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.timestampsUnixNano, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_Sample, rhs: Opentelemetry_Proto_Profiles_V1development_Sample) -> Bool {
    if lhs.locationsStartIndex != rhs.locationsStartIndex {return false}
    if lhs.locationsLength != rhs.locationsLength {return false}
    if lhs.value != rhs.value {return false}
    if lhs.attributeIndices != rhs.attributeIndices {return false}
    if lhs._linkIndex != rhs._linkIndex {return false}
    if lhs.timestampsUnixNano != rhs.timestampsUnixNano {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_Mapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Mapping"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "memory_start"),
    2: .standard(proto: "memory_limit"),
    3: .standard(proto: "file_offset"),
    4: .standard(proto: "filename_strindex"),
    5: .standard(proto: "attribute_indices"),
    6: .standard(proto: "has_functions"),
    7: .standard(proto: "has_filenames"),
    8: .standard(proto: "has_line_numbers"),
    9: .standard(proto: "has_inline_frames"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.memoryStart) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.memoryLimit) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.fileOffset) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.filenameStrindex) }()
      case 5: try { try decoder.decodeRepeatedInt32Field(value: &self.attributeIndices) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.hasFunctions_p) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.hasFilenames_p) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.hasLineNumbers_p) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.hasInlineFrames_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.memoryStart != 0 {
      try visitor.visitSingularUInt64Field(value: self.memoryStart, fieldNumber: 1)
    }
    if self.memoryLimit != 0 {
      try visitor.visitSingularUInt64Field(value: self.memoryLimit, fieldNumber: 2)
    }
    if self.fileOffset != 0 {
      try visitor.visitSingularUInt64Field(value: self.fileOffset, fieldNumber: 3)
    }
    if self.filenameStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.filenameStrindex, fieldNumber: 4)
    }
    if !self.attributeIndices.isEmpty {
      try visitor.visitPackedInt32Field(value: self.attributeIndices, fieldNumber: 5)
    }
    if self.hasFunctions_p != false {
      try visitor.visitSingularBoolField(value: self.hasFunctions_p, fieldNumber: 6)
    }
    if self.hasFilenames_p != false {
      try visitor.visitSingularBoolField(value: self.hasFilenames_p, fieldNumber: 7)
    }
    if self.hasLineNumbers_p != false {
      try visitor.visitSingularBoolField(value: self.hasLineNumbers_p, fieldNumber: 8)
    }
    if self.hasInlineFrames_p != false {
      try visitor.visitSingularBoolField(value: self.hasInlineFrames_p, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_Mapping, rhs: Opentelemetry_Proto_Profiles_V1development_Mapping) -> Bool {
    if lhs.memoryStart != rhs.memoryStart {return false}
    if lhs.memoryLimit != rhs.memoryLimit {return false}
    if lhs.fileOffset != rhs.fileOffset {return false}
    if lhs.filenameStrindex != rhs.filenameStrindex {return false}
    if lhs.attributeIndices != rhs.attributeIndices {return false}
    if lhs.hasFunctions_p != rhs.hasFunctions_p {return false}
    if lhs.hasFilenames_p != rhs.hasFilenames_p {return false}
    if lhs.hasLineNumbers_p != rhs.hasLineNumbers_p {return false}
    if lhs.hasInlineFrames_p != rhs.hasInlineFrames_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Location"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mapping_index"),
    2: .same(proto: "address"),
    3: .same(proto: "line"),
    4: .standard(proto: "is_folded"),
    5: .standard(proto: "attribute_indices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._mappingIndex) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.line) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isFolded) }()
      case 5: try { try decoder.decodeRepeatedInt32Field(value: &self.attributeIndices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mappingIndex {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 2)
    }
    if !self.line.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.line, fieldNumber: 3)
    }
    if self.isFolded != false {
      try visitor.visitSingularBoolField(value: self.isFolded, fieldNumber: 4)
    }
    if !self.attributeIndices.isEmpty {
      try visitor.visitPackedInt32Field(value: self.attributeIndices, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_Location, rhs: Opentelemetry_Proto_Profiles_V1development_Location) -> Bool {
    if lhs._mappingIndex != rhs._mappingIndex {return false}
    if lhs.address != rhs.address {return false}
    if lhs.line != rhs.line {return false}
    if lhs.isFolded != rhs.isFolded {return false}
    if lhs.attributeIndices != rhs.attributeIndices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_Line: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Line"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "function_index"),
    2: .same(proto: "line"),
    3: .same(proto: "column"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.functionIndex) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.line) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.column) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.functionIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.functionIndex, fieldNumber: 1)
    }
    if self.line != 0 {
      try visitor.visitSingularInt64Field(value: self.line, fieldNumber: 2)
    }
    if self.column != 0 {
      try visitor.visitSingularInt64Field(value: self.column, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_Line, rhs: Opentelemetry_Proto_Profiles_V1development_Line) -> Bool {
    if lhs.functionIndex != rhs.functionIndex {return false}
    if lhs.line != rhs.line {return false}
    if lhs.column != rhs.column {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_Function: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Function"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "name_strindex"),
    2: .standard(proto: "system_name_strindex"),
    3: .standard(proto: "filename_strindex"),
    4: .standard(proto: "start_line"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.nameStrindex) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.systemNameStrindex) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.filenameStrindex) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.startLine) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nameStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.nameStrindex, fieldNumber: 1)
    }
    if self.systemNameStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.systemNameStrindex, fieldNumber: 2)
    }
    if self.filenameStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.filenameStrindex, fieldNumber: 3)
    }
    if self.startLine != 0 {
      try visitor.visitSingularInt64Field(value: self.startLine, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_Function, rhs: Opentelemetry_Proto_Profiles_V1development_Function) -> Bool {
    if lhs.nameStrindex != rhs.nameStrindex {return false}
    if lhs.systemNameStrindex != rhs.systemNameStrindex {return false}
    if lhs.filenameStrindex != rhs.filenameStrindex {return false}
    if lhs.startLine != rhs.startLine {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
