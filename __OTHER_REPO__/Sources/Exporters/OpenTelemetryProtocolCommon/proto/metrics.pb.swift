// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: opentelemetry/proto/metrics/v1/metrics.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// AggregationTemporality defines how a metric aggregator reports aggregated
/// values. It describes how those values relate to the time interval over
/// which they are aggregated.
public enum Opentelemetry_Proto_Metrics_V1_AggregationTemporality: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// UNSPECIFIED is the default AggregationTemporality, it MUST not be used.
  case unspecified // = 0

  /// DELTA is an AggregationTemporality for a metric aggregator which reports
  /// changes since last report time. Successive metrics contain aggregation of
  /// values from continuous and non-overlapping intervals.
  ///
  /// The values for a DELTA metric are based only on the time interval
  /// associated with one measurement cycle. There is no dependency on
  /// previous measurements like is the case for CUMULATIVE metrics.
  ///
  /// For example, consider a system measuring the number of requests that
  /// it receives and reports the sum of these requests every second as a
  /// DELTA metric:
  ///
  ///   1. The system starts receiving at time=t_0.
  ///   2. A request is received, the system measures 1 request.
  ///   3. A request is received, the system measures 1 request.
  ///   4. A request is received, the system measures 1 request.
  ///   5. The 1 second collection cycle ends. A metric is exported for the
  ///      number of requests received over the interval of time t_0 to
  ///      t_0+1 with a value of 3.
  ///   6. A request is received, the system measures 1 request.
  ///   7. A request is received, the system measures 1 request.
  ///   8. The 1 second collection cycle ends. A metric is exported for the
  ///      number of requests received over the interval of time t_0+1 to
  ///      t_0+2 with a value of 2.
  case delta // = 1

  /// CUMULATIVE is an AggregationTemporality for a metric aggregator which
  /// reports changes since a fixed start time. This means that current values
  /// of a CUMULATIVE metric depend on all previous measurements since the
  /// start time. Because of this, the sender is required to retain this state
  /// in some form. If this state is lost or invalidated, the CUMULATIVE metric
  /// values MUST be reset and a new fixed start time following the last
  /// reported measurement time sent MUST be used.
  ///
  /// For example, consider a system measuring the number of requests that
  /// it receives and reports the sum of these requests every second as a
  /// CUMULATIVE metric:
  ///
  ///   1. The system starts receiving at time=t_0.
  ///   2. A request is received, the system measures 1 request.
  ///   3. A request is received, the system measures 1 request.
  ///   4. A request is received, the system measures 1 request.
  ///   5. The 1 second collection cycle ends. A metric is exported for the
  ///      number of requests received over the interval of time t_0 to
  ///      t_0+1 with a value of 3.
  ///   6. A request is received, the system measures 1 request.
  ///   7. A request is received, the system measures 1 request.
  ///   8. The 1 second collection cycle ends. A metric is exported for the
  ///      number of requests received over the interval of time t_0 to
  ///      t_0+2 with a value of 5.
  ///   9. The system experiences a fault and loses state.
  ///   10. The system recovers and resumes receiving at time=t_1.
  ///   11. A request is received, the system measures 1 request.
  ///   12. The 1 second collection cycle ends. A metric is exported for the
  ///      number of requests received over the interval of time t_1 to
  ///      t_0+1 with a value of 1.
  ///
  /// Note: Even though, when reporting changes since last report time, using
  /// CUMULATIVE is valid, it is not recommended. This may cause problems for
  /// systems that do not use start_time to determine when the aggregation
  /// value was reset (e.g. Prometheus).
  case cumulative // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .delta
    case 2: self = .cumulative
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .delta: return 1
    case .cumulative: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Opentelemetry_Proto_Metrics_V1_AggregationTemporality] = [
    .unspecified,
    .delta,
    .cumulative,
  ]

}

/// DataPointFlags is defined as a protobuf 'uint32' type and is to be used as a
/// bit-field representing 32 distinct boolean flags.  Each flag defined in this
/// enum is a bit-mask.  To test the presence of a single flag in the flags of
/// a data point, for example, use an expression like:
///
///   (point.flags & DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK) == DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK
public enum Opentelemetry_Proto_Metrics_V1_DataPointFlags: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// The zero value for the enum. Should not be used for comparisons.
  /// Instead use bitwise "and" with the appropriate mask as shown above.
  case doNotUse // = 0

  /// This DataPoint is valid but has no recorded value.  This value
  /// SHOULD be used to reflect explicitly missing data in a series, as
  /// for an equivalent to the Prometheus "staleness marker".
  case noRecordedValueMask // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .doNotUse
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .doNotUse
    case 1: self = .noRecordedValueMask
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .doNotUse: return 0
    case .noRecordedValueMask: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Opentelemetry_Proto_Metrics_V1_DataPointFlags] = [
    .doNotUse,
    .noRecordedValueMask,
  ]

}

/// MetricsData represents the metrics data that can be stored in a persistent
/// storage, OR can be embedded by other protocols that transfer OTLP metrics
/// data but do not implement the OTLP protocol.
///
/// MetricsData
/// └─── ResourceMetrics
///   ├── Resource
///   ├── SchemaURL
///   └── ScopeMetrics
///      ├── Scope
///      ├── SchemaURL
///      └── Metric
///         ├── Name
///         ├── Description
///         ├── Unit
///         └── data
///            ├── Gauge
///            ├── Sum
///            ├── Histogram
///            ├── ExponentialHistogram
///            └── Summary
///
/// The main difference between this message and collector protocol is that
/// in this message there will not be any "control" or "metadata" specific to
/// OTLP protocol.
///
/// When new fields are added into this message, the OTLP request MUST be updated
/// as well.
public struct Opentelemetry_Proto_Metrics_V1_MetricsData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An array of ResourceMetrics.
  /// For data coming from a single resource this array will typically contain
  /// one element. Intermediary nodes that receive data from multiple origins
  /// typically batch the data before forwarding further and in that case this
  /// array will contain multiple elements.
  public var resourceMetrics: [Opentelemetry_Proto_Metrics_V1_ResourceMetrics] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A collection of ScopeMetrics from a Resource.
public struct Opentelemetry_Proto_Metrics_V1_ResourceMetrics: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource for the metrics in this message.
  /// If this field is not set then no resource info is known.
  public var resource: Opentelemetry_Proto_Resource_V1_Resource {
    get {return _resource ?? Opentelemetry_Proto_Resource_V1_Resource()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  /// A list of metrics that originate from a resource.
  public var scopeMetrics: [Opentelemetry_Proto_Metrics_V1_ScopeMetrics] = []

  /// The Schema URL, if known. This is the identifier of the Schema that the resource data
  /// is recorded in. Notably, the last part of the URL path is the version number of the
  /// schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
  /// https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
  /// This schema_url applies to the data in the "resource" field. It does not apply
  /// to the data in the "scope_metrics" field which have their own schema_url field.
  public var schemaURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _resource: Opentelemetry_Proto_Resource_V1_Resource? = nil
}

/// A collection of Metrics produced by an Scope.
public struct Opentelemetry_Proto_Metrics_V1_ScopeMetrics: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instrumentation scope information for the metrics in this message.
  /// Semantically when InstrumentationScope isn't set, it is equivalent with
  /// an empty instrumentation scope name (unknown).
  public var scope: Opentelemetry_Proto_Common_V1_InstrumentationScope {
    get {return _scope ?? Opentelemetry_Proto_Common_V1_InstrumentationScope()}
    set {_scope = newValue}
  }
  /// Returns true if `scope` has been explicitly set.
  public var hasScope: Bool {return self._scope != nil}
  /// Clears the value of `scope`. Subsequent reads from it will return its default value.
  public mutating func clearScope() {self._scope = nil}

  /// A list of metrics that originate from an instrumentation library.
  public var metrics: [Opentelemetry_Proto_Metrics_V1_Metric] = []

  /// The Schema URL, if known. This is the identifier of the Schema that the metric data
  /// is recorded in. Notably, the last part of the URL path is the version number of the
  /// schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
  /// https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
  /// This schema_url applies to all metrics in the "metrics" field.
  public var schemaURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _scope: Opentelemetry_Proto_Common_V1_InstrumentationScope? = nil
}

/// Defines a Metric which has one or more timeseries.  The following is a
/// brief summary of the Metric data model.  For more details, see:
///
///   https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/data-model.md
///
/// The data model and relation between entities is shown in the
/// diagram below. Here, "DataPoint" is the term used to refer to any
/// one of the specific data point value types, and "points" is the term used
/// to refer to any one of the lists of points contained in the Metric.
///
/// - Metric is composed of a metadata and data.
/// - Metadata part contains a name, description, unit.
/// - Data is one of the possible types (Sum, Gauge, Histogram, Summary).
/// - DataPoint contains timestamps, attributes, and one of the possible value type
///   fields.
///
///    Metric
///  +------------+
///  |name        |
///  |description |
///  |unit        |     +------------------------------------+
///  |data        |---> |Gauge, Sum, Histogram, Summary, ... |
///  +------------+     +------------------------------------+
///
///    Data [One of Gauge, Sum, Histogram, Summary, ...]
///  +-----------+
///  |...        |  // Metadata about the Data.
///  |points     |--+
///  +-----------+  |
///                 |      +---------------------------+
///                 |      |DataPoint 1                |
///                 v      |+------+------+   +------+ |
///              +-----+   ||label |label |...|label | |
///              |  1  |-->||value1|value2|...|valueN| |
///              +-----+   |+------+------+   +------+ |
///              |  .  |   |+-----+                    |
///              |  .  |   ||value|                    |
///              |  .  |   |+-----+                    |
///              |  .  |   +---------------------------+
///              |  .  |                   .
///              |  .  |                   .
///              |  .  |                   .
///              |  .  |   +---------------------------+
///              |  .  |   |DataPoint M                |
///              +-----+   |+------+------+   +------+ |
///              |  M  |-->||label |label |...|label | |
///              +-----+   ||value1|value2|...|valueN| |
///                        |+------+------+   +------+ |
///                        |+-----+                    |
///                        ||value|                    |
///                        |+-----+                    |
///                        +---------------------------+
///
/// Each distinct type of DataPoint represents the output of a specific
/// aggregation function, the result of applying the DataPoint's
/// associated function of to one or more measurements.
///
/// All DataPoint types have three common fields:
/// - Attributes includes key-value pairs associated with the data point
/// - TimeUnixNano is required, set to the end time of the aggregation
/// - StartTimeUnixNano is optional, but strongly encouraged for DataPoints
///   having an AggregationTemporality field, as discussed below.
///
/// Both TimeUnixNano and StartTimeUnixNano values are expressed as
/// UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
///
/// # TimeUnixNano
///
/// This field is required, having consistent interpretation across
/// DataPoint types.  TimeUnixNano is the moment corresponding to when
/// the data point's aggregate value was captured.
///
/// Data points with the 0 value for TimeUnixNano SHOULD be rejected
/// by consumers.
///
/// # StartTimeUnixNano
///
/// StartTimeUnixNano in general allows detecting when a sequence of
/// observations is unbroken.  This field indicates to consumers the
/// start time for points with cumulative and delta
/// AggregationTemporality, and it should be included whenever possible
/// to support correct rate calculation.  Although it may be omitted
/// when the start time is truly unknown, setting StartTimeUnixNano is
/// strongly encouraged.
public struct Opentelemetry_Proto_Metrics_V1_Metric: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name of the metric.
  public var name: String = String()

  /// description of the metric, which can be used in documentation.
  public var description_p: String = String()

  /// unit in which the metric value is reported. Follows the format
  /// described by http://unitsofmeasure.org/ucum.html.
  public var unit: String = String()

  /// Data determines the aggregation type (if any) of the metric, what is the
  /// reported value type for the data points, as well as the relatationship to
  /// the time interval over which they are reported.
  public var data: Opentelemetry_Proto_Metrics_V1_Metric.OneOf_Data? = nil

  public var gauge: Opentelemetry_Proto_Metrics_V1_Gauge {
    get {
      if case .gauge(let v)? = data {return v}
      return Opentelemetry_Proto_Metrics_V1_Gauge()
    }
    set {data = .gauge(newValue)}
  }

  public var sum: Opentelemetry_Proto_Metrics_V1_Sum {
    get {
      if case .sum(let v)? = data {return v}
      return Opentelemetry_Proto_Metrics_V1_Sum()
    }
    set {data = .sum(newValue)}
  }

  public var histogram: Opentelemetry_Proto_Metrics_V1_Histogram {
    get {
      if case .histogram(let v)? = data {return v}
      return Opentelemetry_Proto_Metrics_V1_Histogram()
    }
    set {data = .histogram(newValue)}
  }

  public var exponentialHistogram: Opentelemetry_Proto_Metrics_V1_ExponentialHistogram {
    get {
      if case .exponentialHistogram(let v)? = data {return v}
      return Opentelemetry_Proto_Metrics_V1_ExponentialHistogram()
    }
    set {data = .exponentialHistogram(newValue)}
  }

  public var summary: Opentelemetry_Proto_Metrics_V1_Summary {
    get {
      if case .summary(let v)? = data {return v}
      return Opentelemetry_Proto_Metrics_V1_Summary()
    }
    set {data = .summary(newValue)}
  }

  /// Additional metadata attributes that describe the metric. [Optional].
  /// Attributes are non-identifying.
  /// Consumers SHOULD NOT need to be aware of these attributes.
  /// These attributes MAY be used to encode information allowing
  /// for lossless roundtrip translation to / from another data model.
  /// Attribute keys MUST be unique (it is not allowed to have more than one
  /// attribute with the same key).
  public var metadata: [Opentelemetry_Proto_Common_V1_KeyValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Data determines the aggregation type (if any) of the metric, what is the
  /// reported value type for the data points, as well as the relatationship to
  /// the time interval over which they are reported.
  public enum OneOf_Data: Equatable, Sendable {
    case gauge(Opentelemetry_Proto_Metrics_V1_Gauge)
    case sum(Opentelemetry_Proto_Metrics_V1_Sum)
    case histogram(Opentelemetry_Proto_Metrics_V1_Histogram)
    case exponentialHistogram(Opentelemetry_Proto_Metrics_V1_ExponentialHistogram)
    case summary(Opentelemetry_Proto_Metrics_V1_Summary)

  }

  public init() {}
}

/// Gauge represents the type of a scalar metric that always exports the
/// "current value" for every data point. It should be used for an "unknown"
/// aggregation.
///
/// A Gauge does not support different aggregation temporalities. Given the
/// aggregation is unknown, points cannot be combined using the same
/// aggregation, regardless of aggregation temporalities. Therefore,
/// AggregationTemporality is not included. Consequently, this also means
/// "StartTimeUnixNano" is ignored for all data points.
public struct Opentelemetry_Proto_Metrics_V1_Gauge: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dataPoints: [Opentelemetry_Proto_Metrics_V1_NumberDataPoint] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Sum represents the type of a scalar metric that is calculated as a sum of all
/// reported measurements over a time interval.
public struct Opentelemetry_Proto_Metrics_V1_Sum: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dataPoints: [Opentelemetry_Proto_Metrics_V1_NumberDataPoint] = []

  /// aggregation_temporality describes if the aggregator reports delta changes
  /// since last report time, or cumulative changes since a fixed start time.
  public var aggregationTemporality: Opentelemetry_Proto_Metrics_V1_AggregationTemporality = .unspecified

  /// If "true" means that the sum is monotonic.
  public var isMonotonic: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Histogram represents the type of a metric that is calculated by aggregating
/// as a Histogram of all reported measurements over a time interval.
public struct Opentelemetry_Proto_Metrics_V1_Histogram: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dataPoints: [Opentelemetry_Proto_Metrics_V1_HistogramDataPoint] = []

  /// aggregation_temporality describes if the aggregator reports delta changes
  /// since last report time, or cumulative changes since a fixed start time.
  public var aggregationTemporality: Opentelemetry_Proto_Metrics_V1_AggregationTemporality = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ExponentialHistogram represents the type of a metric that is calculated by aggregating
/// as a ExponentialHistogram of all reported double measurements over a time interval.
public struct Opentelemetry_Proto_Metrics_V1_ExponentialHistogram: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dataPoints: [Opentelemetry_Proto_Metrics_V1_ExponentialHistogramDataPoint] = []

  /// aggregation_temporality describes if the aggregator reports delta changes
  /// since last report time, or cumulative changes since a fixed start time.
  public var aggregationTemporality: Opentelemetry_Proto_Metrics_V1_AggregationTemporality = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Summary metric data are used to convey quantile summaries,
/// a Prometheus (see: https://prometheus.io/docs/concepts/metric_types/#summary)
/// and OpenMetrics (see: https://github.com/OpenObservability/OpenMetrics/blob/4dbf6075567ab43296eed941037c12951faafb92/protos/prometheus.proto#L45)
/// data type. These data points cannot always be merged in a meaningful way.
/// While they can be useful in some applications, histogram data points are
/// recommended for new applications.
/// Summary metrics do not have an aggregation temporality field. This is
/// because the count and sum fields of a SummaryDataPoint are assumed to be
/// cumulative values.
public struct Opentelemetry_Proto_Metrics_V1_Summary: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dataPoints: [Opentelemetry_Proto_Metrics_V1_SummaryDataPoint] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// NumberDataPoint is a single data point in a timeseries that describes the
/// time-varying scalar value of a metric.
public struct Opentelemetry_Proto_Metrics_V1_NumberDataPoint: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of key/value pairs that uniquely identify the timeseries from
  /// where this point belongs. The list may be empty (may contain 0 elements).
  /// Attribute keys MUST be unique (it is not allowed to have more than one
  /// attribute with the same key).
  public var attributes: [Opentelemetry_Proto_Common_V1_KeyValue] = []

  /// StartTimeUnixNano is optional but strongly encouraged, see the
  /// the detailed comments above Metric.
  ///
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  public var startTimeUnixNano: UInt64 = 0

  /// TimeUnixNano is required, see the detailed comments above Metric.
  ///
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  public var timeUnixNano: UInt64 = 0

  /// The value itself.  A point is considered invalid when one of the recognized
  /// value fields is not present inside this oneof.
  public var value: Opentelemetry_Proto_Metrics_V1_NumberDataPoint.OneOf_Value? = nil

  public var asDouble: Double {
    get {
      if case .asDouble(let v)? = value {return v}
      return 0
    }
    set {value = .asDouble(newValue)}
  }

  public var asInt: Int64 {
    get {
      if case .asInt(let v)? = value {return v}
      return 0
    }
    set {value = .asInt(newValue)}
  }

  /// (Optional) List of exemplars collected from
  /// measurements that were used to form the data point
  public var exemplars: [Opentelemetry_Proto_Metrics_V1_Exemplar] = []

  /// Flags that apply to this specific data point.  See DataPointFlags
  /// for the available flags and their meaning.
  public var flags: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The value itself.  A point is considered invalid when one of the recognized
  /// value fields is not present inside this oneof.
  public enum OneOf_Value: Equatable, Sendable {
    case asDouble(Double)
    case asInt(Int64)

  }

  public init() {}
}

/// HistogramDataPoint is a single data point in a timeseries that describes the
/// time-varying values of a Histogram. A Histogram contains summary statistics
/// for a population of values, it may optionally contain the distribution of
/// those values across a set of buckets.
///
/// If the histogram contains the distribution of values, then both
/// "explicit_bounds" and "bucket counts" fields must be defined.
/// If the histogram does not contain the distribution of values, then both
/// "explicit_bounds" and "bucket_counts" must be omitted and only "count" and
/// "sum" are known.
public struct Opentelemetry_Proto_Metrics_V1_HistogramDataPoint: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of key/value pairs that uniquely identify the timeseries from
  /// where this point belongs. The list may be empty (may contain 0 elements).
  /// Attribute keys MUST be unique (it is not allowed to have more than one
  /// attribute with the same key).
  public var attributes: [Opentelemetry_Proto_Common_V1_KeyValue] = []

  /// StartTimeUnixNano is optional but strongly encouraged, see the
  /// the detailed comments above Metric.
  ///
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  public var startTimeUnixNano: UInt64 = 0

  /// TimeUnixNano is required, see the detailed comments above Metric.
  ///
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  public var timeUnixNano: UInt64 = 0

  /// count is the number of values in the population. Must be non-negative. This
  /// value must be equal to the sum of the "count" fields in buckets if a
  /// histogram is provided.
  public var count: UInt64 = 0

  /// sum of the values in the population. If count is zero then this field
  /// must be zero.
  ///
  /// Note: Sum should only be filled out when measuring non-negative discrete
  /// events, and is assumed to be monotonic over the values of these events.
  /// Negative events *can* be recorded, but sum should not be filled out when
  /// doing so.  This is specifically to enforce compatibility w/ OpenMetrics,
  /// see: https://github.com/prometheus/OpenMetrics/blob/v1.0.0/specification/OpenMetrics.md#histogram
  public var sum: Double {
    get {return _sum ?? 0}
    set {_sum = newValue}
  }
  /// Returns true if `sum` has been explicitly set.
  public var hasSum: Bool {return self._sum != nil}
  /// Clears the value of `sum`. Subsequent reads from it will return its default value.
  public mutating func clearSum() {self._sum = nil}

  /// bucket_counts is an optional field contains the count values of histogram
  /// for each bucket.
  ///
  /// The sum of the bucket_counts must equal the value in the count field.
  ///
  /// The number of elements in bucket_counts array must be by one greater than
  /// the number of elements in explicit_bounds array.
  public var bucketCounts: [UInt64] = []

  /// explicit_bounds specifies buckets with explicitly defined bounds for values.
  ///
  /// The boundaries for bucket at index i are:
  ///
  /// (-infinity, explicit_bounds[i]] for i == 0
  /// (explicit_bounds[i-1], explicit_bounds[i]] for 0 < i < size(explicit_bounds)
  /// (explicit_bounds[i-1], +infinity) for i == size(explicit_bounds)
  ///
  /// The values in the explicit_bounds array must be strictly increasing.
  ///
  /// Histogram buckets are inclusive of their upper boundary, except the last
  /// bucket where the boundary is at infinity. This format is intentionally
  /// compatible with the OpenMetrics histogram definition.
  public var explicitBounds: [Double] = []

  /// (Optional) List of exemplars collected from
  /// measurements that were used to form the data point
  public var exemplars: [Opentelemetry_Proto_Metrics_V1_Exemplar] = []

  /// Flags that apply to this specific data point.  See DataPointFlags
  /// for the available flags and their meaning.
  public var flags: UInt32 = 0

  /// min is the minimum value over (start_time, end_time].
  public var min: Double {
    get {return _min ?? 0}
    set {_min = newValue}
  }
  /// Returns true if `min` has been explicitly set.
  public var hasMin: Bool {return self._min != nil}
  /// Clears the value of `min`. Subsequent reads from it will return its default value.
  public mutating func clearMin() {self._min = nil}

  /// max is the maximum value over (start_time, end_time].
  public var max: Double {
    get {return _max ?? 0}
    set {_max = newValue}
  }
  /// Returns true if `max` has been explicitly set.
  public var hasMax: Bool {return self._max != nil}
  /// Clears the value of `max`. Subsequent reads from it will return its default value.
  public mutating func clearMax() {self._max = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sum: Double? = nil
  fileprivate var _min: Double? = nil
  fileprivate var _max: Double? = nil
}

/// ExponentialHistogramDataPoint is a single data point in a timeseries that describes the
/// time-varying values of a ExponentialHistogram of double values. A ExponentialHistogram contains
/// summary statistics for a population of values, it may optionally contain the
/// distribution of those values across a set of buckets.
public struct Opentelemetry_Proto_Metrics_V1_ExponentialHistogramDataPoint: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of key/value pairs that uniquely identify the timeseries from
  /// where this point belongs. The list may be empty (may contain 0 elements).
  /// Attribute keys MUST be unique (it is not allowed to have more than one
  /// attribute with the same key).
  public var attributes: [Opentelemetry_Proto_Common_V1_KeyValue] = []

  /// StartTimeUnixNano is optional but strongly encouraged, see the
  /// the detailed comments above Metric.
  ///
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  public var startTimeUnixNano: UInt64 = 0

  /// TimeUnixNano is required, see the detailed comments above Metric.
  ///
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  public var timeUnixNano: UInt64 = 0

  /// count is the number of values in the population. Must be
  /// non-negative. This value must be equal to the sum of the "bucket_counts"
  /// values in the positive and negative Buckets plus the "zero_count" field.
  public var count: UInt64 = 0

  /// sum of the values in the population. If count is zero then this field
  /// must be zero.
  ///
  /// Note: Sum should only be filled out when measuring non-negative discrete
  /// events, and is assumed to be monotonic over the values of these events.
  /// Negative events *can* be recorded, but sum should not be filled out when
  /// doing so.  This is specifically to enforce compatibility w/ OpenMetrics,
  /// see: https://github.com/prometheus/OpenMetrics/blob/v1.0.0/specification/OpenMetrics.md#histogram
  public var sum: Double {
    get {return _sum ?? 0}
    set {_sum = newValue}
  }
  /// Returns true if `sum` has been explicitly set.
  public var hasSum: Bool {return self._sum != nil}
  /// Clears the value of `sum`. Subsequent reads from it will return its default value.
  public mutating func clearSum() {self._sum = nil}

  /// scale describes the resolution of the histogram.  Boundaries are
  /// located at powers of the base, where:
  ///
  ///   base = (2^(2^-scale))
  ///
  /// The histogram bucket identified by `index`, a signed integer,
  /// contains values that are greater than (base^index) and
  /// less than or equal to (base^(index+1)).
  ///
  /// The positive and negative ranges of the histogram are expressed
  /// separately.  Negative values are mapped by their absolute value
  /// into the negative range using the same scale as the positive range.
  ///
  /// scale is not restricted by the protocol, as the permissible
  /// values depend on the range of the data.
  public var scale: Int32 = 0

  /// zero_count is the count of values that are either exactly zero or
  /// within the region considered zero by the instrumentation at the
  /// tolerated degree of precision.  This bucket stores values that
  /// cannot be expressed using the standard exponential formula as
  /// well as values that have been rounded to zero.
  ///
  /// Implementations MAY consider the zero bucket to have probability
  /// mass equal to (zero_count / count).
  public var zeroCount: UInt64 = 0

  /// positive carries the positive range of exponential bucket counts.
  public var positive: Opentelemetry_Proto_Metrics_V1_ExponentialHistogramDataPoint.Buckets {
    get {return _positive ?? Opentelemetry_Proto_Metrics_V1_ExponentialHistogramDataPoint.Buckets()}
    set {_positive = newValue}
  }
  /// Returns true if `positive` has been explicitly set.
  public var hasPositive: Bool {return self._positive != nil}
  /// Clears the value of `positive`. Subsequent reads from it will return its default value.
  public mutating func clearPositive() {self._positive = nil}

  /// negative carries the negative range of exponential bucket counts.
  public var negative: Opentelemetry_Proto_Metrics_V1_ExponentialHistogramDataPoint.Buckets {
    get {return _negative ?? Opentelemetry_Proto_Metrics_V1_ExponentialHistogramDataPoint.Buckets()}
    set {_negative = newValue}
  }
  /// Returns true if `negative` has been explicitly set.
  public var hasNegative: Bool {return self._negative != nil}
  /// Clears the value of `negative`. Subsequent reads from it will return its default value.
  public mutating func clearNegative() {self._negative = nil}

  /// Flags that apply to this specific data point.  See DataPointFlags
  /// for the available flags and their meaning.
  public var flags: UInt32 = 0

  /// (Optional) List of exemplars collected from
  /// measurements that were used to form the data point
  public var exemplars: [Opentelemetry_Proto_Metrics_V1_Exemplar] = []

  /// min is the minimum value over (start_time, end_time].
  public var min: Double {
    get {return _min ?? 0}
    set {_min = newValue}
  }
  /// Returns true if `min` has been explicitly set.
  public var hasMin: Bool {return self._min != nil}
  /// Clears the value of `min`. Subsequent reads from it will return its default value.
  public mutating func clearMin() {self._min = nil}

  /// max is the maximum value over (start_time, end_time].
  public var max: Double {
    get {return _max ?? 0}
    set {_max = newValue}
  }
  /// Returns true if `max` has been explicitly set.
  public var hasMax: Bool {return self._max != nil}
  /// Clears the value of `max`. Subsequent reads from it will return its default value.
  public mutating func clearMax() {self._max = nil}

  /// ZeroThreshold may be optionally set to convey the width of the zero
  /// region. Where the zero region is defined as the closed interval
  /// [-ZeroThreshold, ZeroThreshold].
  /// When ZeroThreshold is 0, zero count bucket stores values that cannot be
  /// expressed using the standard exponential formula as well as values that
  /// have been rounded to zero.
  public var zeroThreshold: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Buckets are a set of bucket counts, encoded in a contiguous array
  /// of counts.
  public struct Buckets: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Offset is the bucket index of the first entry in the bucket_counts array.
    /// 
    /// Note: This uses a varint encoding as a simple form of compression.
    public var offset: Int32 = 0

    /// bucket_counts is an array of count values, where bucket_counts[i] carries
    /// the count of the bucket at index (offset+i). bucket_counts[i] is the count
    /// of values greater than base^(offset+i) and less than or equal to
    /// base^(offset+i+1).
    ///
    /// Note: By contrast, the explicit HistogramDataPoint uses
    /// fixed64.  This field is expected to have many buckets,
    /// especially zeros, so uint64 has been selected to ensure
    /// varint encoding.
    public var bucketCounts: [UInt64] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _sum: Double? = nil
  fileprivate var _positive: Opentelemetry_Proto_Metrics_V1_ExponentialHistogramDataPoint.Buckets? = nil
  fileprivate var _negative: Opentelemetry_Proto_Metrics_V1_ExponentialHistogramDataPoint.Buckets? = nil
  fileprivate var _min: Double? = nil
  fileprivate var _max: Double? = nil
}

/// SummaryDataPoint is a single data point in a timeseries that describes the
/// time-varying values of a Summary metric. The count and sum fields represent
/// cumulative values.
public struct Opentelemetry_Proto_Metrics_V1_SummaryDataPoint: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of key/value pairs that uniquely identify the timeseries from
  /// where this point belongs. The list may be empty (may contain 0 elements).
  /// Attribute keys MUST be unique (it is not allowed to have more than one
  /// attribute with the same key).
  public var attributes: [Opentelemetry_Proto_Common_V1_KeyValue] = []

  /// StartTimeUnixNano is optional but strongly encouraged, see the
  /// the detailed comments above Metric.
  ///
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  public var startTimeUnixNano: UInt64 = 0

  /// TimeUnixNano is required, see the detailed comments above Metric.
  ///
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  public var timeUnixNano: UInt64 = 0

  /// count is the number of values in the population. Must be non-negative.
  public var count: UInt64 = 0

  /// sum of the values in the population. If count is zero then this field
  /// must be zero.
  ///
  /// Note: Sum should only be filled out when measuring non-negative discrete
  /// events, and is assumed to be monotonic over the values of these events.
  /// Negative events *can* be recorded, but sum should not be filled out when
  /// doing so.  This is specifically to enforce compatibility w/ OpenMetrics,
  /// see: https://github.com/prometheus/OpenMetrics/blob/v1.0.0/specification/OpenMetrics.md#summary
  public var sum: Double = 0

  /// (Optional) list of values at different quantiles of the distribution calculated
  /// from the current snapshot. The quantiles must be strictly increasing.
  public var quantileValues: [Opentelemetry_Proto_Metrics_V1_SummaryDataPoint.ValueAtQuantile] = []

  /// Flags that apply to this specific data point.  See DataPointFlags
  /// for the available flags and their meaning.
  public var flags: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Represents the value at a given quantile of a distribution.
  ///
  /// To record Min and Max values following conventions are used:
  /// - The 1.0 quantile is equivalent to the maximum value observed.
  /// - The 0.0 quantile is equivalent to the minimum value observed.
  ///
  /// See the following issue for more context:
  /// https://github.com/open-telemetry/opentelemetry-proto/issues/125
  public struct ValueAtQuantile: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The quantile of a distribution. Must be in the interval
    /// [0.0, 1.0].
    public var quantile: Double = 0

    /// The value at the given quantile of a distribution.
    ///
    /// Quantile values must NOT be negative.
    public var value: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// A representation of an exemplar, which is a sample input measurement.
/// Exemplars also hold information about the environment when the measurement
/// was recorded, for example the span and trace ID of the active span when the
/// exemplar was recorded.
public struct Opentelemetry_Proto_Metrics_V1_Exemplar: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of key/value pairs that were filtered out by the aggregator, but
  /// recorded alongside the original measurement. Only key/value pairs that were
  /// filtered out by the aggregator should be included
  public var filteredAttributes: [Opentelemetry_Proto_Common_V1_KeyValue] = []

  /// time_unix_nano is the exact time when this exemplar was recorded
  ///
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  public var timeUnixNano: UInt64 = 0

  /// The value of the measurement that was recorded. An exemplar is
  /// considered invalid when one of the recognized value fields is not present
  /// inside this oneof.
  public var value: Opentelemetry_Proto_Metrics_V1_Exemplar.OneOf_Value? = nil

  public var asDouble: Double {
    get {
      if case .asDouble(let v)? = value {return v}
      return 0
    }
    set {value = .asDouble(newValue)}
  }

  public var asInt: Int64 {
    get {
      if case .asInt(let v)? = value {return v}
      return 0
    }
    set {value = .asInt(newValue)}
  }

  /// (Optional) Span ID of the exemplar trace.
  /// span_id may be missing if the measurement is not recorded inside a trace
  /// or if the trace is not sampled.
  public var spanID: Data = Data()

  /// (Optional) Trace ID of the exemplar trace.
  /// trace_id may be missing if the measurement is not recorded inside a trace
  /// or if the trace is not sampled.
  public var traceID: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The value of the measurement that was recorded. An exemplar is
  /// considered invalid when one of the recognized value fields is not present
  /// inside this oneof.
  public enum OneOf_Value: Equatable, Sendable {
    case asDouble(Double)
    case asInt(Int64)

  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "opentelemetry.proto.metrics.v1"

extension Opentelemetry_Proto_Metrics_V1_AggregationTemporality: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AGGREGATION_TEMPORALITY_UNSPECIFIED"),
    1: .same(proto: "AGGREGATION_TEMPORALITY_DELTA"),
    2: .same(proto: "AGGREGATION_TEMPORALITY_CUMULATIVE"),
  ]
}

extension Opentelemetry_Proto_Metrics_V1_DataPointFlags: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DATA_POINT_FLAGS_DO_NOT_USE"),
    1: .same(proto: "DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK"),
  ]
}

extension Opentelemetry_Proto_Metrics_V1_MetricsData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetricsData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resource_metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.resourceMetrics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceMetrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resourceMetrics, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_MetricsData, rhs: Opentelemetry_Proto_Metrics_V1_MetricsData) -> Bool {
    if lhs.resourceMetrics != rhs.resourceMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_ResourceMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resource"),
    2: .standard(proto: "scope_metrics"),
    3: .standard(proto: "schema_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.scopeMetrics) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.schemaURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.scopeMetrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.scopeMetrics, fieldNumber: 2)
    }
    if !self.schemaURL.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_ResourceMetrics, rhs: Opentelemetry_Proto_Metrics_V1_ResourceMetrics) -> Bool {
    if lhs._resource != rhs._resource {return false}
    if lhs.scopeMetrics != rhs.scopeMetrics {return false}
    if lhs.schemaURL != rhs.schemaURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_ScopeMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScopeMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
    2: .same(proto: "metrics"),
    3: .standard(proto: "schema_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._scope) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.metrics) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.schemaURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._scope {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.metrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metrics, fieldNumber: 2)
    }
    if !self.schemaURL.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_ScopeMetrics, rhs: Opentelemetry_Proto_Metrics_V1_ScopeMetrics) -> Bool {
    if lhs._scope != rhs._scope {return false}
    if lhs.metrics != rhs.metrics {return false}
    if lhs.schemaURL != rhs.schemaURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_Metric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Metric"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .same(proto: "unit"),
    5: .same(proto: "gauge"),
    7: .same(proto: "sum"),
    9: .same(proto: "histogram"),
    10: .standard(proto: "exponential_histogram"),
    11: .same(proto: "summary"),
    12: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.unit) }()
      case 5: try {
        var v: Opentelemetry_Proto_Metrics_V1_Gauge?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .gauge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .gauge(v)
        }
      }()
      case 7: try {
        var v: Opentelemetry_Proto_Metrics_V1_Sum?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .sum(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .sum(v)
        }
      }()
      case 9: try {
        var v: Opentelemetry_Proto_Metrics_V1_Histogram?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .histogram(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .histogram(v)
        }
      }()
      case 10: try {
        var v: Opentelemetry_Proto_Metrics_V1_ExponentialHistogram?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .exponentialHistogram(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .exponentialHistogram(v)
        }
      }()
      case 11: try {
        var v: Opentelemetry_Proto_Metrics_V1_Summary?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .summary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .summary(v)
        }
      }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.unit.isEmpty {
      try visitor.visitSingularStringField(value: self.unit, fieldNumber: 3)
    }
    switch self.data {
    case .gauge?: try {
      guard case .gauge(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .sum?: try {
      guard case .sum(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .histogram?: try {
      guard case .histogram(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .exponentialHistogram?: try {
      guard case .exponentialHistogram(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .summary?: try {
      guard case .summary(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    if !self.metadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadata, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_Metric, rhs: Opentelemetry_Proto_Metrics_V1_Metric) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.data != rhs.data {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_Gauge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Gauge"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_points"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dataPoints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_Gauge, rhs: Opentelemetry_Proto_Metrics_V1_Gauge) -> Bool {
    if lhs.dataPoints != rhs.dataPoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_Sum: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Sum"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_points"),
    2: .standard(proto: "aggregation_temporality"),
    3: .standard(proto: "is_monotonic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dataPoints) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.aggregationTemporality) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isMonotonic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
    }
    if self.aggregationTemporality != .unspecified {
      try visitor.visitSingularEnumField(value: self.aggregationTemporality, fieldNumber: 2)
    }
    if self.isMonotonic != false {
      try visitor.visitSingularBoolField(value: self.isMonotonic, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_Sum, rhs: Opentelemetry_Proto_Metrics_V1_Sum) -> Bool {
    if lhs.dataPoints != rhs.dataPoints {return false}
    if lhs.aggregationTemporality != rhs.aggregationTemporality {return false}
    if lhs.isMonotonic != rhs.isMonotonic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_Histogram: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Histogram"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_points"),
    2: .standard(proto: "aggregation_temporality"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dataPoints) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.aggregationTemporality) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
    }
    if self.aggregationTemporality != .unspecified {
      try visitor.visitSingularEnumField(value: self.aggregationTemporality, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_Histogram, rhs: Opentelemetry_Proto_Metrics_V1_Histogram) -> Bool {
    if lhs.dataPoints != rhs.dataPoints {return false}
    if lhs.aggregationTemporality != rhs.aggregationTemporality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_ExponentialHistogram: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExponentialHistogram"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_points"),
    2: .standard(proto: "aggregation_temporality"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dataPoints) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.aggregationTemporality) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
    }
    if self.aggregationTemporality != .unspecified {
      try visitor.visitSingularEnumField(value: self.aggregationTemporality, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_ExponentialHistogram, rhs: Opentelemetry_Proto_Metrics_V1_ExponentialHistogram) -> Bool {
    if lhs.dataPoints != rhs.dataPoints {return false}
    if lhs.aggregationTemporality != rhs.aggregationTemporality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_Summary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Summary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_points"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dataPoints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_Summary, rhs: Opentelemetry_Proto_Metrics_V1_Summary) -> Bool {
    if lhs.dataPoints != rhs.dataPoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_NumberDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NumberDataPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    7: .same(proto: "attributes"),
    2: .standard(proto: "start_time_unix_nano"),
    3: .standard(proto: "time_unix_nano"),
    4: .standard(proto: "as_double"),
    6: .standard(proto: "as_int"),
    5: .same(proto: "exemplars"),
    8: .same(proto: "flags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano) }()
      case 3: try { try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano) }()
      case 4: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .asDouble(v)
        }
      }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.exemplars) }()
      case 6: try {
        var v: Int64?
        try decoder.decodeSingularSFixed64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .asInt(v)
        }
      }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.attributes) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.flags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.startTimeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
    }
    try { if case .asDouble(let v)? = self.value {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    } }()
    if !self.exemplars.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exemplars, fieldNumber: 5)
    }
    try { if case .asInt(let v)? = self.value {
      try visitor.visitSingularSFixed64Field(value: v, fieldNumber: 6)
    } }()
    if !self.attributes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attributes, fieldNumber: 7)
    }
    if self.flags != 0 {
      try visitor.visitSingularUInt32Field(value: self.flags, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_NumberDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_NumberDataPoint) -> Bool {
    if lhs.attributes != rhs.attributes {return false}
    if lhs.startTimeUnixNano != rhs.startTimeUnixNano {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.value != rhs.value {return false}
    if lhs.exemplars != rhs.exemplars {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_HistogramDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HistogramDataPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    9: .same(proto: "attributes"),
    2: .standard(proto: "start_time_unix_nano"),
    3: .standard(proto: "time_unix_nano"),
    4: .same(proto: "count"),
    5: .same(proto: "sum"),
    6: .standard(proto: "bucket_counts"),
    7: .standard(proto: "explicit_bounds"),
    8: .same(proto: "exemplars"),
    10: .same(proto: "flags"),
    11: .same(proto: "min"),
    12: .same(proto: "max"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano) }()
      case 3: try { try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano) }()
      case 4: try { try decoder.decodeSingularFixed64Field(value: &self.count) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self._sum) }()
      case 6: try { try decoder.decodeRepeatedFixed64Field(value: &self.bucketCounts) }()
      case 7: try { try decoder.decodeRepeatedDoubleField(value: &self.explicitBounds) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.exemplars) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.attributes) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.flags) }()
      case 11: try { try decoder.decodeSingularDoubleField(value: &self._min) }()
      case 12: try { try decoder.decodeSingularDoubleField(value: &self._max) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.startTimeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
    }
    if self.count != 0 {
      try visitor.visitSingularFixed64Field(value: self.count, fieldNumber: 4)
    }
    try { if let v = self._sum {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    } }()
    if !self.bucketCounts.isEmpty {
      try visitor.visitPackedFixed64Field(value: self.bucketCounts, fieldNumber: 6)
    }
    if !self.explicitBounds.isEmpty {
      try visitor.visitPackedDoubleField(value: self.explicitBounds, fieldNumber: 7)
    }
    if !self.exemplars.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exemplars, fieldNumber: 8)
    }
    if !self.attributes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attributes, fieldNumber: 9)
    }
    if self.flags != 0 {
      try visitor.visitSingularUInt32Field(value: self.flags, fieldNumber: 10)
    }
    try { if let v = self._min {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._max {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_HistogramDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_HistogramDataPoint) -> Bool {
    if lhs.attributes != rhs.attributes {return false}
    if lhs.startTimeUnixNano != rhs.startTimeUnixNano {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.count != rhs.count {return false}
    if lhs._sum != rhs._sum {return false}
    if lhs.bucketCounts != rhs.bucketCounts {return false}
    if lhs.explicitBounds != rhs.explicitBounds {return false}
    if lhs.exemplars != rhs.exemplars {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs._min != rhs._min {return false}
    if lhs._max != rhs._max {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_ExponentialHistogramDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExponentialHistogramDataPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attributes"),
    2: .standard(proto: "start_time_unix_nano"),
    3: .standard(proto: "time_unix_nano"),
    4: .same(proto: "count"),
    5: .same(proto: "sum"),
    6: .same(proto: "scale"),
    7: .standard(proto: "zero_count"),
    8: .same(proto: "positive"),
    9: .same(proto: "negative"),
    10: .same(proto: "flags"),
    11: .same(proto: "exemplars"),
    12: .same(proto: "min"),
    13: .same(proto: "max"),
    14: .standard(proto: "zero_threshold"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.attributes) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano) }()
      case 3: try { try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano) }()
      case 4: try { try decoder.decodeSingularFixed64Field(value: &self.count) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self._sum) }()
      case 6: try { try decoder.decodeSingularSInt32Field(value: &self.scale) }()
      case 7: try { try decoder.decodeSingularFixed64Field(value: &self.zeroCount) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._positive) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._negative) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.flags) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.exemplars) }()
      case 12: try { try decoder.decodeSingularDoubleField(value: &self._min) }()
      case 13: try { try decoder.decodeSingularDoubleField(value: &self._max) }()
      case 14: try { try decoder.decodeSingularDoubleField(value: &self.zeroThreshold) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.attributes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attributes, fieldNumber: 1)
    }
    if self.startTimeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
    }
    if self.count != 0 {
      try visitor.visitSingularFixed64Field(value: self.count, fieldNumber: 4)
    }
    try { if let v = self._sum {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    } }()
    if self.scale != 0 {
      try visitor.visitSingularSInt32Field(value: self.scale, fieldNumber: 6)
    }
    if self.zeroCount != 0 {
      try visitor.visitSingularFixed64Field(value: self.zeroCount, fieldNumber: 7)
    }
    try { if let v = self._positive {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._negative {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if self.flags != 0 {
      try visitor.visitSingularUInt32Field(value: self.flags, fieldNumber: 10)
    }
    if !self.exemplars.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exemplars, fieldNumber: 11)
    }
    try { if let v = self._min {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._max {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 13)
    } }()
    if self.zeroThreshold.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.zeroThreshold, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_ExponentialHistogramDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_ExponentialHistogramDataPoint) -> Bool {
    if lhs.attributes != rhs.attributes {return false}
    if lhs.startTimeUnixNano != rhs.startTimeUnixNano {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.count != rhs.count {return false}
    if lhs._sum != rhs._sum {return false}
    if lhs.scale != rhs.scale {return false}
    if lhs.zeroCount != rhs.zeroCount {return false}
    if lhs._positive != rhs._positive {return false}
    if lhs._negative != rhs._negative {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs.exemplars != rhs.exemplars {return false}
    if lhs._min != rhs._min {return false}
    if lhs._max != rhs._max {return false}
    if lhs.zeroThreshold != rhs.zeroThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_ExponentialHistogramDataPoint.Buckets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opentelemetry_Proto_Metrics_V1_ExponentialHistogramDataPoint.protoMessageName + ".Buckets"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offset"),
    2: .standard(proto: "bucket_counts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularSInt32Field(value: &self.offset) }()
      case 2: try { try decoder.decodeRepeatedUInt64Field(value: &self.bucketCounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.offset != 0 {
      try visitor.visitSingularSInt32Field(value: self.offset, fieldNumber: 1)
    }
    if !self.bucketCounts.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.bucketCounts, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_ExponentialHistogramDataPoint.Buckets, rhs: Opentelemetry_Proto_Metrics_V1_ExponentialHistogramDataPoint.Buckets) -> Bool {
    if lhs.offset != rhs.offset {return false}
    if lhs.bucketCounts != rhs.bucketCounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_SummaryDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SummaryDataPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    7: .same(proto: "attributes"),
    2: .standard(proto: "start_time_unix_nano"),
    3: .standard(proto: "time_unix_nano"),
    4: .same(proto: "count"),
    5: .same(proto: "sum"),
    6: .standard(proto: "quantile_values"),
    8: .same(proto: "flags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano) }()
      case 3: try { try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano) }()
      case 4: try { try decoder.decodeSingularFixed64Field(value: &self.count) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.sum) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.quantileValues) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.attributes) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.flags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startTimeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
    }
    if self.count != 0 {
      try visitor.visitSingularFixed64Field(value: self.count, fieldNumber: 4)
    }
    if self.sum.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.sum, fieldNumber: 5)
    }
    if !self.quantileValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.quantileValues, fieldNumber: 6)
    }
    if !self.attributes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attributes, fieldNumber: 7)
    }
    if self.flags != 0 {
      try visitor.visitSingularUInt32Field(value: self.flags, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_SummaryDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_SummaryDataPoint) -> Bool {
    if lhs.attributes != rhs.attributes {return false}
    if lhs.startTimeUnixNano != rhs.startTimeUnixNano {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.count != rhs.count {return false}
    if lhs.sum != rhs.sum {return false}
    if lhs.quantileValues != rhs.quantileValues {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_SummaryDataPoint.ValueAtQuantile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opentelemetry_Proto_Metrics_V1_SummaryDataPoint.protoMessageName + ".ValueAtQuantile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "quantile"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.quantile) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.quantile.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.quantile, fieldNumber: 1)
    }
    if self.value.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_SummaryDataPoint.ValueAtQuantile, rhs: Opentelemetry_Proto_Metrics_V1_SummaryDataPoint.ValueAtQuantile) -> Bool {
    if lhs.quantile != rhs.quantile {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_Exemplar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Exemplar"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    7: .standard(proto: "filtered_attributes"),
    2: .standard(proto: "time_unix_nano"),
    3: .standard(proto: "as_double"),
    6: .standard(proto: "as_int"),
    4: .standard(proto: "span_id"),
    5: .standard(proto: "trace_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano) }()
      case 3: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .asDouble(v)
        }
      }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.spanID) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.traceID) }()
      case 6: try {
        var v: Int64?
        try decoder.decodeSingularSFixed64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .asInt(v)
        }
      }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.filteredAttributes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 2)
    }
    try { if case .asDouble(let v)? = self.value {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    } }()
    if !self.spanID.isEmpty {
      try visitor.visitSingularBytesField(value: self.spanID, fieldNumber: 4)
    }
    if !self.traceID.isEmpty {
      try visitor.visitSingularBytesField(value: self.traceID, fieldNumber: 5)
    }
    try { if case .asInt(let v)? = self.value {
      try visitor.visitSingularSFixed64Field(value: v, fieldNumber: 6)
    } }()
    if !self.filteredAttributes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filteredAttributes, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_Exemplar, rhs: Opentelemetry_Proto_Metrics_V1_Exemplar) -> Bool {
    if lhs.filteredAttributes != rhs.filteredAttributes {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.value != rhs.value {return false}
    if lhs.spanID != rhs.spanID {return false}
    if lhs.traceID != rhs.traceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
